%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{FLAP}
\date{Sep 29, 2020}
\release{}
\author{S.\@{} Zoletnik et al.\@{}}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Welcome to the FLAP documentation. This main page points to the start
of a great journey in exploring the Fusion Library of Analysis Programs
Python package.


\chapter{FLAP Styleguide}
\label{\detokenize{styleguide:flap-styleguide}}\label{\detokenize{styleguide::doc}}\begin{quote}

written by Gabor Csehlast modified: 1st December 2019
\end{quote}

The purpose of this document is to give an overview of the coding style requirements for developing the main components of the Fusion Library of Analysis Programs (FLAP) package. (It is not a requirement for developing your own user programs, however, it is still suggested to use this coding style, even when just using FLAP. Or always.).

The coding style in FLAP package follows the \sphinxhref{https://www.python.org/dev/peps/pep-0008/}{PEP 8} style guide (see examples later), so if you are already know it’s rules, you are good to go. Otherwise here are some useful tips about installing and using a style\sphinxhyphen{} and code\sphinxhyphen{}checking extension (\sphinxhref{http://flake8.pycqa.org/en/latest/}{flake8}) in Visual Studio Code and Spyder.


\section{Extensions/packages for style checking}
\label{\detokenize{styleguide:extensions-packages-for-style-checking}}
Before getting to the actual code style guide, here is the list of packages/extensions, one can use to automatically check the style of one’s coding.


\subsection{Python extension for Visual Studio Code}
\label{\detokenize{styleguide:python-extension-for-visual-studio-code}}
\sphinxhref{https://code.visualstudio.com/}{Visual Studio Code} is an open source, cross\sphinxhyphen{}platform code editor, which is widely used in many environments, e.g. it is available from the Anaconda Python distribution.

To install flake8 code analyzer, you have to install first the \sphinxhref{https://github.com/Microsoft/vscode-python}{Python extension} for VSCode:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Go to the Extension sidebar (or press Ctrl+Shift+X).

\item {} 
Type Python into the “Search Extension in Marketplace” search field.

\item {} 
Click on the green Install button.

\item {} 
That’s it!

\end{enumerate}

After installing the Python extension, a text will appear on the bottom sidebar of the VSCode window, which says Python a version number and 32/64 bit in the form of “Python 3.7.2 64\sphinxhyphen{}bit”. By clicking on this text, you can select the Python version, you want to use for code analysis, and running your Python programs. This list contains (in principle) all the available Python installations on your machine, not just the ones, which are in the PATH variable.

To have your code checked, you need to install a linting module to your Python installation. The recommended module for this is flake8 (as mentioned before), which not only checks your code, but also analyze your programs and notices you about uninitialized/unused variables etc.

To install flake8, you just have to set VSCode settings accordingly. This means, that go to File \textendash{}\textgreater{} Preferences \textendash{}\textgreater{} Settings (Ctrl+,). Then type “python.” in the search bar, and click on the “edit in settings.json” option (it appears multiple times, it does not matter, which one you click on). Then you have to insert the following lines or \sphinxhyphen{} if they are present \sphinxhyphen{} check, that the settings are the same as below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}python.linting.pylintEnabled\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}python.linting.flake8Enabled\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}python.linting.enabled\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}python.linting.flake8Args\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
        \PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZhy{}max\PYGZhy{}line\PYGZhy{}length=120\PYGZdq{}}
    \PYG{p}{]}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If you have no flake8 installed with your Python distribution, an automatic message will come up, offering the possibility to install this module automatically. You can choose either this to install flake8 (in this case, an embedded command line will come up inside the VSCode window and install the extension), or you can install it manually by using the

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} python \PYGZhy{}m pip install flake8
\end{sphinxVerbatim}

In this manual case, take care that you use the python version you mean, and not another installation.

After installing flake8, the style and code analysis messages will appear in a dedicated block, if you click the error/warning sign icons in the navigation bar at the bottom of the screen.


\subsection{Python with Spyder}
\label{\detokenize{styleguide:python-with-spyder}}
Since Spyder is optimized solely around the Python language, Spyder is coming pylint preinstalled, so to have a good linter, you just have to switch it on. You have to check on the:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tools \PYGZhy{}\PYGZhy{}\PYGZgt{} Preferences \PYGZhy{}\PYGZhy{}\PYGZgt{} Editor \PYGZhy{}\PYGZhy{}\PYGZgt{} Code Instrospection/Analysis \PYGZhy{}\PYGZhy{}\PYGZgt{}
Real\PYGZhy{}time code style analysis
\end{sphinxVerbatim}

checkbox, and you are good to go. After checking this checkmark and applying the settings, the warning/error messages will appear next to the line numbering with a yellow warning sign. Hovering the mouse over these warning signs will give you the exact message.


\section{Style guide \sphinxhyphen{} a short summary}
\label{\detokenize{styleguide:style-guide-a-short-summary}}
Since we follow the guidelines articulated in \sphinxhref{https://www.python.org/dev/peps/pep-0008/\#}{Python Enchancment Proposal 8 (PEP 8)}, if something is not clear and/or not written in this document, this is a good web page to start. Otherwise I try to give a short, but comprehensive summary about the ideas described there.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Use 4 spaces for indentation \sphinxhyphen{} no tabs!! (It can be easily set in modern code editors, even VI(m) has this possibility. It is called either “indent using spaces” or “soft tab”.)

\item {} 
No trailing spaces at the end of the line.

\item {} 
Line continuation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Aligned with opening delimiter.}
\PYG{n}{foo} \PYG{o}{=} \PYG{n}{long\PYGZus{}function\PYGZus{}name}\PYG{p}{(}\PYG{n}{var\PYGZus{}one}\PYG{p}{,} \PYG{n}{var\PYGZus{}two}\PYG{p}{,}
                        \PYG{n}{var\PYGZus{}three}\PYG{p}{,} \PYG{n}{var\PYGZus{}four}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add 4 spaces (an extra level of indentation) to distinguish}
\PYG{c+c1}{\PYGZsh{} arguments from the rest.}
\PYG{k}{def} \PYG{n+nf}{long\PYGZus{}function\PYGZus{}name}\PYG{p}{(}
        \PYG{n}{var\PYGZus{}one}\PYG{p}{,} \PYG{n}{var\PYGZus{}two}\PYG{p}{,} \PYG{n}{var\PYGZus{}three}\PYG{p}{,}
        \PYG{n}{var\PYGZus{}four}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{var\PYGZus{}one}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The closing brace/bracket/parenthesis on multiline constructs}
\PYG{c+c1}{\PYGZsh{} line up under the first non\PYGZhy{}whitespace character of the last}
\PYG{c+c1}{\PYGZsh{} line of list (or the first character of the line)}
\PYG{n}{my\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,}
    \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,}
    \PYG{p}{]}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{some\PYGZus{}function\PYGZus{}that\PYGZus{}takes\PYGZus{}arguments}\PYG{p}{(}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Line length: \sphinxstylestrong{79 characters} for code, \sphinxstylestrong{72 characters} for docstrings/comments. The original argument for this decision is:
\begin{quote}

Limiting the required editor window width makes it possible to have several files open side\sphinxhyphen{}by\sphinxhyphen{}side, and works well when using code review tools that present the two versions in adjacent columns.
\end{quote}

However, if this is not the case at your coding style (means you use one ), it is allowed (as a local rule) to use \sphinxstylestrong{120 characters} for code and/or docstrings/comments.

\item {} 
Wrapping long lines:
\begin{quote}

The preferred way of wrapping long lines is by using Python’s implied line continuation inside parentheses, brackets and braces. Long lines can be broken over multiple lines by wrapping expressions in parentheses. These should be used in preference to using a backslash for line continuation.
Backslashes may still be appropriate at times. For example, long, multiple with\sphinxhyphen{}statements cannot use implicit continuation, so backslashes are acceptable:
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/path/to/some/file/you/want/to/read}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file\PYGZus{}1}\PYG{p}{,} \PYGZbs{}
     \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/path/to/some/file/being/written}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file\PYGZus{}2}\PYG{p}{:}
    \PYG{n}{file\PYGZus{}2}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{file\PYGZus{}1}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Line breaks with binary operators (short: operator should be \sphinxstyleemphasis{before} the operand):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Yes: easy to match operators with operands}
\PYG{n}{income} \PYG{o}{=} \PYG{p}{(}\PYG{n}{gross\PYGZus{}wages}
          \PYG{o}{+} \PYG{n}{taxable\PYGZus{}interest}
          \PYG{o}{+} \PYG{p}{(}\PYG{n}{dividends} \PYG{o}{\PYGZhy{}} \PYG{n}{qualified\PYGZus{}dividends}\PYG{p}{)}
          \PYG{o}{\PYGZhy{}} \PYG{n}{ira\PYGZus{}deduction}
          \PYG{o}{\PYGZhy{}} \PYG{n}{student\PYGZus{}loan\PYGZus{}interest}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Blank lines.
\begin{itemize}
\item {} 
Surround \sphinxstyleemphasis{\sphinxstylestrong{top\sphinxhyphen{}level functions}} and \sphinxstyleemphasis{\sphinxstylestrong{class definitions}} with \sphinxstyleemphasis{\sphinxstylestrong{two}} blank lines.

\item {} 
\sphinxstyleemphasis{\sphinxstylestrong{Method definitions}} inside a class are surrounded by a \sphinxstyleemphasis{\sphinxstylestrong{single}} blank line.

\item {} 
Use blank lines in functions, sparingly, to indicate logical sections.

\end{itemize}

\item {} 
Source file encoding: \sphinxhref{https://en.wikipedia.org/wiki/UTF-8}{UTF\sphinxhyphen{}8}. Set this every time. However, you should use English words and ASCII \sphinxstyleemphasis{characters} in those files. Except explicit test cases for non\sphinxhyphen{}ASCII characters and author names.

\item {} 
Naming conventions
\begin{itemize}
\item {} 
Names to avoid: ‘l’ (lowercase letter L), ‘o’ (lowercase letter ‘oh’), ‘I’ (uppercase letter ‘eye’) as single\sphinxhyphen{}letter variable names. Reason: confusing.

\item {} 
All the names should be ASCII compatibility (however, the character\sphinxhyphen{}encoding is UTF\sphinxhyphen{}8).

\item {} 
\sphinxstyleemphasis{\sphinxstylestrong{Module}} names should be \sphinxstyleemphasis{\sphinxstylestrong{short, lowercase}} letters (like flap).

\item {} 
\sphinxstyleemphasis{\sphinxstylestrong{Class names: CamelCase.}}

\item {} 
\sphinxstyleemphasis{\sphinxstylestrong{Function names: lowercase}}, words separated by \sphinxstyleemphasis{\sphinxstylestrong{underscores.}}

\item {} 
Always use self for the first argument to instance methods.

\item {} 
Always use cls for the first argument to class methods.

\item {} 
At name collision (e.g. with a reserved keyword) use a trailing underscore. E.g. class\_.

\end{itemize}

\end{enumerate}


\section{Logging}
\label{\detokenize{styleguide:logging}}
Instead of using print messages and verbose keywords etc. throughout the whole code, it it strongly advised to use \sphinxhref{https://docs.python.org/3.7/library/logging.html}{Python’s built\sphinxhyphen{}in logging system}. It is capable of save the log messages in a stream, on the console or in a file (actually, the latter two are also kinds of streams) based on predefined criterions, e.g. severity. The logging system is easy\sphinxhyphen{}to\sphinxhyphen{}use and easy\sphinxhyphen{}to\sphinxhyphen{}config. Some examples are below.
\begin{itemize}
\item {} 
A logging.conf file for the logger setup.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[loggers]
keys=root,flapLogger

[handlers]
keys=consoleHandler,fileHandler

[formatters]
keys=fileFormatter,consoleFormatter

[logger\PYGZus{}root]
level=DEBUG
handlers=consoleHandler

[logger\PYGZus{}edvisLogger]
level=DEBUG
handlers=consoleHandler,fileHandler
qualname=edvisLogger
propagate=0

[handler\PYGZus{}fileHandler]
class=logging.handlers.RotatingFileHandler
level=DEBUG
formatter=fileFormatter
args=(\PYGZsq{}./flap.log\PYGZsq{}, \PYGZsq{}a\PYGZsq{}, 5*1024*1024, 1)

[handler\PYGZus{}consoleHandler]
class=StreamHandler
level=INFO
formatter=consoleFormatter
args=(sys.stdout,)

[formatter\PYGZus{}fileFormatter]
format=\PYGZpc{}(asctime)s \PYGZhy{} \PYGZpc{}(name)s \PYGZhy{} \PYGZpc{}(filename)s \PYGZhy{} line: \PYGZpc{}(lineno)s \PYGZhy{}
\PYGZpc{}(levelname)s \PYGZhy{} \PYGZpc{}(message)s
datefmt=

[formatter\PYGZus{}consoleFormatter]
format=\PYGZpc{}(asctime)s \PYGZhy{} \PYGZpc{}(levelname)s \PYGZhy{} \PYGZpc{}(message)s
datefmt=
\end{sphinxVerbatim}

\item {} 
Usage of the logger after setting up a logging.conf file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{k+kn}{import} \PYG{n+nn}{logging}\PYG{n+nn}{.}\PYG{n+nn}{config}

\PYG{c+c1}{\PYGZsh{} Loading the logger config file}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{fileConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{logging.conf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create logger}
\PYG{n}{logger} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flapLogger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{logger}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The FLAP logger facility has been initialized.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Doing some everyday work (only need info about that if we are in verbose mode)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pam pam param...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{logger}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Here is some verbose, debug level logging message}
              \PYG{n}{about} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pam pam param...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Documentation strings}
\label{\detokenize{styleguide:documentation-strings}}
The \sphinxhref{http://www.sphinx-doc.org/en/master/index.html}{Sphinx Python Documentation Generation} system uses \sphinxhref{http://docutils.sourceforge.net/rst.html}{reStructuredText (RST)} (for quick editing purposes, use \sphinxhref{https://github.com/ralsina/rst-cheatsheet/blob/master/rst-cheatsheet.rst}{this cheat sheet}) to generate documentation for various formats include HTML, PDF, DOCX and various ebook formats.

It is capable of creating a whole documentation with separate documents (e.g. tutorials, detailed explanations, intentions etc.), but from the user point of view, the most important parts are the so\sphinxhyphen{}called docstrings. These are comment\sphinxhyphen{}like sections in the source code, where the user can on\sphinxhyphen{}the\sphinxhyphen{}fly describe the purpose and usage of the given part of the code. There are a few examples below.

A full code example (grabbed from the \sphinxhref{https://pythonhosted.org/an\_example\_pypi\_project/sphinx.html}{following link}) is below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{.. module:: useful\PYGZus{}1}
\PYG{l+s+sd}{   :platform: Unix, Windows}
\PYG{l+s+sd}{   :synopsis: A useful module indeed.}

\PYG{l+s+sd}{.. moduleauthor:: Albert Example \PYGZlt{}albert@invalid.com\PYGZgt{}}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}


\PYG{k}{def} \PYG{n+nf}{public\PYGZus{}fn\PYGZus{}with\PYGZus{}sphinxy\PYGZus{}docstring}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{state}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}This function does something.}

\PYG{l+s+sd}{    :param name: The name to use.}
\PYG{l+s+sd}{    :type name: str.}
\PYG{l+s+sd}{    :param state: Current state to be in.}
\PYG{l+s+sd}{    :type state: bool.}
\PYG{l+s+sd}{    :returns:  int \PYGZhy{}\PYGZhy{} the return code.}
\PYG{l+s+sd}{    :raises: AttributeError, KeyError}

\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{l+m+mi}{0}


\PYG{k}{class} \PYG{n+nc}{MyPublicClass}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}We use this as a public class example class.}

\PYG{l+s+sd}{    You never call this class before calling :func:`public\PYGZus{}fn\PYGZus{}with\PYGZus{}sphinxy\PYGZus{}docstring`.}

\PYG{l+s+sd}{    .. note::}

\PYG{l+s+sd}{       An example of intersphinx is this: you **cannot** use :mod:`pickle` on this class.}

\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{foo}\PYG{p}{,} \PYG{n}{bar}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{baz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A really simple class.}

\PYG{l+s+sd}{        :param foo: We all know what foo does.}
\PYG{l+s+sd}{        :type foo: str.}
\PYG{l+s+sd}{        :param bar: Really, same as foo.}
\PYG{l+s+sd}{        :type bar: str.}

\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}foo} \PYG{o}{=} \PYG{n}{foo}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}bar} \PYG{o}{=} \PYG{n}{bar}
\end{sphinxVerbatim}


\section{How to create the documentation}
\label{\detokenize{styleguide:how-to-create-the-documentation}}
After properly written the documentation strings in the code, one can generate the full documentation of the project. To do this, you need to follow the steps below.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Install \sphinxhref{http://www.sphinx-doc.org/en/master/}{Sphinx}:

\end{enumerate}
\begin{quote}

pip install \sphinxhyphen{}U Sphinx
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Navigate into your \sphinxstyleemphasis{\sphinxstylestrong{documentation}} (not necessarily the same as the code) directory and type:

\end{enumerate}
\begin{quote}

sphinx\sphinxhyphen{}quickstart
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
You’ll need to answer a few questions (see \sphinxhref{https://pythonhosted.org/an\_example\_pypi\_project/sphinx.html\#sphinx-quickstart}{this link}).

\item {} 
You got a basic documentation!

\end{enumerate}

Of course, the documentation can be tweaked later by hand and manual pages can also be added later. PDFs and various ebook file types also can be generated, but the default is a HTML structure, where you can search and navigate.

If you want to update the existing (html) documentation, you should write (on Windows) the following command in the documentation source directory.
\begin{quote}

make.bat html
\end{quote}

Of course, if you need any other format, you can use that as well. For example
\begin{quote}

make.bat latex
\end{quote}

will generate LaTeX files for you, from which you can generate e.g. a pdf document.
\begin{quote}

make.bat epub
\end{quote}

will generate an ebook format of your documentation.

The documentation by default is written in ReStructured Text format (.rst file extension), but there is a possibility to extend Sphinx’s capabilities to recognize MarkDown format (.md). For this you have to install the recommonmark module for your Python distribution with the following command.
\begin{quote}

pip install recommonmark
\end{quote}


\chapter{FLAP source code documentation}
\label{\detokenize{sourcecode:flap-source-code-documentation}}\label{\detokenize{sourcecode::doc}}
Contents


\section{Config}
\label{\detokenize{config:module-flap.config}}\label{\detokenize{config:config}}\label{\detokenize{config::doc}}\index{module@\spxentry{module}!flap.config@\spxentry{flap.config}}\index{flap.config@\spxentry{flap.config}!module@\spxentry{module}}
Created on Wed Jan 23 21:45:43 2019

@author: Zoletnik
\index{interpret\_config\_value() (in module flap.config)@\spxentry{interpret\_config\_value()}\spxextra{in module flap.config}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{config:flap.config.interpret_config_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.config.}}\sphinxbfcode{\sphinxupquote{interpret\_config\_value}}}{\emph{\DUrole{n}{value\_str}}}{}
Determine the data type from the input string and convert.
Conversions:
‘True’, ‘Yes’ \textendash{}\textgreater{} True
‘False’, ‘No’ \textendash{}\textgreater{} False
Starting and ending with ‘ or ” \textendash{}\textgreater{} string
If can be converted to int, float or complex \textendash{}\textgreater{} converted numeric value
Starting and ending with {[}{]} \textendash{}\textgreater{} list
If all the above fails keep as string

\end{fulllineitems}

\index{merge\_options() (in module flap.config)@\spxentry{merge\_options()}\spxextra{in module flap.config}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{config:flap.config.merge_options}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.config.}}\sphinxbfcode{\sphinxupquote{merge\_options}}}{\emph{\DUrole{n}{default\_options}}, \emph{\DUrole{n}{input\_options}}, \emph{\DUrole{n}{data\_source}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{section}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Merges options dictionaries. Uses default options of function, input options of function and
options read from config file from \textless{}section\textgreater{} section. If exp\_id is set will also look for options
in section Module exp\_id for options starting with \{section\}.
The precedence of options is:
\begin{quote}
\begin{quote}

default\_options \textless{} section options \textless{} module options \textless{} input\_options
\end{quote}
\begin{description}
\item[{INPUT:}] \leavevmode
default\_options: Default options in a function. This should contain all the possible options.
input\_options: Contents of options argument of function. Option keys can also be abbreviated.
data\_source: The data source of the measurement. (May be None)
section: Name of the section in the config file related to the fnction. (May be None.)

\item[{Return value:}] \leavevmode
The merged options dictionary. Abbreviated keys are expanded to full name.

\end{description}
\end{quote}

\end{fulllineitems}



\section{Coordinate}
\label{\detokenize{coordinate:module-flap.coordinate}}\label{\detokenize{coordinate:coordinate}}\label{\detokenize{coordinate::doc}}\index{module@\spxentry{module}!flap.coordinate@\spxentry{flap.coordinate}}\index{flap.coordinate@\spxentry{flap.coordinate}!module@\spxentry{module}}
Created on Wed Jan 23 09:44:50 2019

@author: Zoletnik

This is the coordinate description for FLAP
\index{Coordinate (class in flap.coordinate)@\spxentry{Coordinate}\spxextra{class in flap.coordinate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.coordinate.}}\sphinxbfcode{\sphinxupquote{Coordinate}}}{\emph{name=None}, \emph{unit=None}, \emph{mode=\textless{}flap.coordinate.CoordinateMode object\textgreater{}}, \emph{shape={[}{]}}, \emph{start=None}, \emph{step=None}, \emph{c\_range=None}, \emph{values=None}, \emph{value\_index=None}, \emph{value\_ranges=None}, \emph{dimension\_list={[}{]}}}{}
Class for the description of a mapping of coordinate values from an n\sphinxhyphen{}dimensional coordinate
sample space to coordinates of an m\sphinxhyphen{}dimensional data matrix.
Coordinate sample space is a rectangular equidistant point matrix, with equal steps in each dimension.
For dimension i sample index is from 0…n\sphinxhyphen{}1 if shape{[}i{]} == n
The sample space in this coordinate description does not necessarily match the shape of
any sub\sphinxhyphen{}matrix of the data object. If the shape is different then interpolation is done assuming
the coordinate of the first(last) point of the coordinate matrix is the coordinate of the first(last)
data point.

Coordinate can be anything described by name and unit.
Standard coordinates: Time, Channel, Channel number, Device\_x, Device\_y, Device\_z, Device\_R, Device\_Z, Device\_phi,
\begin{quote}

Flux\_r, Flux\_theta, Flux\_phi, Frequency, Time lag
\end{quote}

See the description of variables in the \_\_init\_\_ function.
The ranges and start\sphinxhyphen{}step pair of inputs are alternatives.
\index{change\_dimensions() (flap.coordinate.Coordinate method)@\spxentry{change\_dimensions()}\spxextra{flap.coordinate.Coordinate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate.change_dimensions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{change\_dimensions}}}{}{}
Return the list of dimensions of the data array along which this coordinate
changes

\end{fulllineitems}

\index{data() (flap.coordinate.Coordinate method)@\spxentry{data()}\spxextra{flap.coordinate.Coordinate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate.data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data}}}{\emph{\DUrole{n}{data\_shape}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{index}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns the coordinates, low and high limits for a sub\sphinxhyphen{}array of the data array in a DataObject.
\begin{description}
\item[{index:}] \leavevmode
list, tuple describing the elements in DataObject.data for which the coordinates are
required. The length of the array should be identical to the number of dimensions
of the data array. Elements can be a mixture of numbers, slice objects, lists, numpy arrays,
integer iterators and ellipses.
Examples for 3D array:
\begin{quote}

(…,0,0) coordinates of the elements in the first row of the data array
(slice(2,5),2,…)
\end{quote}

\item[{data\_shape:}] \leavevmode
The shape of the data array (without slicing) for which coordinates are requested.

\item[{options: Dictionary with options for processing:}] \leavevmode\begin{description}
\item[{‘Interpolation’: ‘Linear’ (default, for non\sphinxhyphen{}equidistant axis when values shape is}] \leavevmode
different from data shape)

\item[{‘Change only’: Return only the data for those dimensions where this coordinate changes.}] \leavevmode
E.g. if it changes only along one dimension the output array will have 1 element
in all other dimensions.

\end{description}

\item[{Return value:}] \leavevmode
values, value\_range\_low, value range\_high
The low and high values are the absolute values not the difference from values

\end{description}

\end{fulllineitems}

\index{data\_range() (flap.coordinate.Coordinate method)@\spxentry{data\_range()}\spxextra{flap.coordinate.Coordinate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate.data_range}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_range}}}{\emph{\DUrole{n}{data\_shape}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns the data range and the data range with errors for the coordinate. Both are lists.

\end{fulllineitems}

\index{dtype() (flap.coordinate.Coordinate method)@\spxentry{dtype()}\spxextra{flap.coordinate.Coordinate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate.dtype}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dtype}}}{}{}
Return the data type of the coordinate.
Returns standard Python types: str, int, float, complex, boolean, object

\end{fulllineitems}

\index{nochange\_dimensions() (flap.coordinate.Coordinate method)@\spxentry{nochange\_dimensions()}\spxextra{flap.coordinate.Coordinate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate.nochange_dimensions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nochange\_dimensions}}}{\emph{\DUrole{n}{data\_shape}}}{}
Return the list of dimensions of the data array along which this coordinate
changes

\end{fulllineitems}

\index{non\_interpol() (flap.coordinate.Coordinate method)@\spxentry{non\_interpol()}\spxextra{flap.coordinate.Coordinate method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Coordinate.non_interpol}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{non\_interpol}}}{\emph{\DUrole{n}{data\_shape}}}{}
Return True if the shape of the coordinate description
is the same as the sub\sphinxhyphen{}data\sphinxhyphen{}array for which it applies and self.value\_index is None.
In this case there is no need for interpolation, just copy coordinate values

Applicable only for non\sphinxhyphen{}equidistant case.

\end{fulllineitems}


\end{fulllineitems}

\index{CoordinateMode (class in flap.coordinate)@\spxentry{CoordinateMode}\spxextra{class in flap.coordinate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.CoordinateMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.coordinate.}}\sphinxbfcode{\sphinxupquote{CoordinateMode}}}{\emph{\DUrole{n}{equidistant}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{range\_symmetric}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Class for storing mode flags of the coordinate description

\end{fulllineitems}

\index{Intervals (class in flap.coordinate)@\spxentry{Intervals}\spxextra{class in flap.coordinate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Intervals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.coordinate.}}\sphinxbfcode{\sphinxupquote{Intervals}}}{\emph{\DUrole{n}{start}}, \emph{\DUrole{n}{stop}}, \emph{\DUrole{n}{step}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{number}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A class to describe a series of intervals.
Regular intevals are identical length ones repeating with a fixed step.
Irregulars are just a list of start\sphinxhyphen{}stop values.
For integer type values both the start and stop value is included.
The optional number gives the number of ranges for the regular intervals.
\index{interval\_limits() (flap.coordinate.Intervals method)@\spxentry{interval\_limits()}\spxextra{flap.coordinate.Intervals method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Intervals.interval_limits}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interval\_limits}}}{\emph{\DUrole{n}{limits}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{partial\_intervals}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Return the range lower and upper limits as two numpy arrays.
Limit the ranges within argument limits. (limits{[}0{]} \textless{} limits{[}1{]})
limits: 2 elements list with lower and upper limit
\begin{description}
\item[{partial\_intervals: Return also partial ranges which extend over limits.}] \leavevmode
Their size will be truncated.

\end{description}

Raises a ValueError if there are no intervals within  limit or other problem.

\end{fulllineitems}

\index{interval\_number() (flap.coordinate.Intervals method)@\spxentry{interval\_number()}\spxextra{flap.coordinate.Intervals method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Intervals.interval_number}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interval\_number}}}{\emph{\DUrole{n}{limits}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{partial\_intervals}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Return the number of intervals and the index of the start interval.
Limit the ranges within argument limits.
limits: 2 elements list with lower and upper limit

partial\_intervals: Take into account also partial ranges which extend over limits.

Raises a ValueError in case of problem.

\end{fulllineitems}


\end{fulllineitems}

\index{Unit (class in flap.coordinate)@\spxentry{Unit}\spxextra{class in flap.coordinate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Unit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.coordinate.}}\sphinxbfcode{\sphinxupquote{Unit}}}{\emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{unit}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
Class for the unit of the data
\index{title() (flap.coordinate.Unit method)@\spxentry{title()}\spxextra{flap.coordinate.Unit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{coordinate:flap.coordinate.Unit.title}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{title}}}{\emph{\DUrole{n}{language}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}EN\textquotesingle{}}}, \emph{\DUrole{n}{complex\_txt}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{new\_unit}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns a title string which will be used in plotting.
complex\_txt: List of 2 numbers:
\begin{quote}

{[}0,0{]}: Amplitude
{[}0,1{]}: Phase
{[}1,0{]}: Real
{[}1,1{]}: Imaginary
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Data object}
\label{\detokenize{data_object:module-flap.data_object}}\label{\detokenize{data_object:data-object}}\label{\detokenize{data_object::doc}}\index{module@\spxentry{module}!flap.data\_object@\spxentry{flap.data\_object}}\index{flap.data\_object@\spxentry{flap.data\_object}!module@\spxentry{module}}
Created on Tue Jan 22 17:37:32 2019

@author: Zoletnik
\index{DataObject (class in flap.data\_object)@\spxentry{DataObject}\spxextra{class in flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{DataObject}}}{\emph{\DUrole{n}{data\_array}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{error}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_unit}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinates}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{info}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_shape}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_source}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This is the data object
\index{add\_coordinate() (flap.data\_object.DataObject method)@\spxentry{add\_coordinate()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.add_coordinate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_coordinate}}}{\emph{\DUrole{n}{coordinates}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_source}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\begin{description}
\item[{This is a general coordinate conversion interface.}] \leavevmode
Adds the requested coordinate(s) to the data\_object.

\item[{INPUT:}] \leavevmode
coordinates: List of coordinates to add. (string array)
data\_source: Optional data\_source. Use this not the one in data\_object
exp\_id: Optional exp\_id. Use this not the one in data\_object
options: Dictionary of options.

\end{description}

Returns the modified data object. Note that the input data object remanins the same.

\end{fulllineitems}

\index{add\_coordinate\_object() (flap.data\_object.DataObject method)@\spxentry{add\_coordinate\_object()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.add_coordinate_object}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_coordinate\_object}}}{\emph{\DUrole{n}{coordinate}}, \emph{\DUrole{n}{index}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a flap.Coordinate instance to the list of coordinates
If index is not set adds to the end of the list. Otherwise adds to the position
shown by index. (0 is beginning of list.)

\end{fulllineitems}

\index{apsd() (flap.data\_object.DataObject method)@\spxentry{apsd()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.apsd}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apsd}}}{\emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Auto power Spectral Density caclculation for the data object d.
Returns a data object with the coordinate replaced by frequency or wavenumber.
The power spectrum is calculated in multiple intervals (described by slicing)
and the mean and variance will be returned.
\begin{description}
\item[{INPUT:}] \leavevmode
d: A flap.DataObject.
coordinate: The name of the coordinate (string) along which to calculate APSD.
\begin{quote}

This coordinate should change only along one data dimension and should be equidistant.
This and all other cordinates changing along the data dimension of
this coordinate will be removed. A new coordinate with name
Frequency/Wavenumber will be added. The unit will be
derived from the unit of the coordinate (e.g., Hz cm\sphinxhyphen{}1, m\sphinxhyphen{}1)
\end{quote}
\begin{description}
\item[{intervals: Information of processing intervals.}] \leavevmode\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.

\item[{options: Dictionary. (Keys can be abbreviated)}] \leavevmode\begin{description}
\item[{‘Wavenumber’}] \leavevmode{[}True/False. Will use 2*Pi*f for the output coordinate scale, this is useful for{]}
wavenumber calculation.

\end{description}

‘Resolution’: Output resolution in the unit of the output coordinate.
‘Range’: Output range in the unit of the output coordinate.
‘Logarithmic’: True/False. If True will create logarithmic frequency binning.
‘Interval\_n’: Minimum number of intervals to use for the processing. These are identical
\begin{quote}

length intervals inserted into the input interval list. Default is 8.
\end{quote}
\begin{description}
\item[{‘Error calculation’}] \leavevmode{[}True/False. Calculate or not error. Omitting error calculation{]}
increases speed. If Interval\_n is 1 no error calculation is done.

\item[{‘Trend removal’: Trend removal description (see also \_trend\_removal()). A list, string or None.}] \leavevmode\begin{quote}
\begin{quote}

None: Don’t remove trend.
Strings:
\begin{quote}

‘mean’: subtract mean
\end{quote}
\begin{description}
\item[{Lists:}] \leavevmode
{[}‘poly’, n{]}: Fit an n order polynomial to the data and subtract.

\end{description}
\end{quote}

Trend removal will be applied to each interval separately.
\end{quote}

‘Hanning’: True/False Use a Hanning window.

\end{description}

\end{description}

\end{description}

Return value: The new data object

This method is implemented by the \_apsd function in spectcral\_analysis.py

\end{fulllineitems}

\index{ccf() (flap.data\_object.DataObject method)@\spxentry{ccf()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.ccf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ccf}}}{\emph{\DUrole{n}{ref}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
N dimensional Cross Correlation Function or covariance calculation for the data object self taking d\_ref
as reference. If ref is not set self is used as reference, that is all CCFs are calculated
within self. Calculates all CCF between all signals in ref and sel, but not inside self and ref.
Correlation is calculated along the coordinate(s) listed in coordinate which should be
identical for the to input data objects.
Returns a data object with dimension number self.dim+ref.dim\sphinxhyphen{}len(coordinate).
The coordinates are replaced by coordinate+’ lag’.
The CCF is calculated in multiple intervals (described by intervals)
and the mean and variance will be returned.
\begin{description}
\item[{INPUT:}] \leavevmode
self: A flap.DataObject.
ref: Another flap.DataObject
coordinate: The name of the coordinate (string) along which to calculate CCF or a list of names.
\begin{quote}

Each coordinate should change only along one data dimension and should be equidistant.
This and all other cordinates changing along the data dimension of
these coordinates will be removed. New coordinates with name+’ lag’ will be added.
\end{quote}
\begin{description}
\item[{intervals: Information of processing intervals.}] \leavevmode\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.

\item[{options: Dictionary. (Keys can be abbreviated)}] \leavevmode
‘Resolution’: Output resolution for each coordinate. (list of values or single value)
‘Range’: Output ranges for each coordinate. (List or list of lists)
‘Interval\_n’: Minimum number of intervals to use for the processing. These are identical
\begin{quote}

length intervals inserted into the input interval list. Default is 8.
\end{quote}
\begin{description}
\item[{‘Error calculation’}] \leavevmode{[}True/False. Calculate or not error. Omitting error calculation{]}
increases speed. If Interval\_n is 1 no error calculation is done.

\item[{‘Trend removal’: Trend removal description (see also \_trend\_removal()). A list, string or None.}] \leavevmode\begin{quote}

None: Don’t remove trend.
Strings:
\begin{quote}

‘mean’: subtract mean
\end{quote}
\begin{description}
\item[{Lists:}] \leavevmode
{[}‘poly’, n{]}: Fit an n order polynomial to the data and subtract.

\end{description}
\end{quote}

Trend removal will be applied to each interval separately.
At present trend removal can be applied to 1D CCF only.

\end{description}

‘Hanning’: True/False Use a Hanning window.
‘Normalize’: Normalize with autocorrelations, that is calculate correlation instead of covariance.

\end{description}

\end{description}

\end{fulllineitems}

\index{check() (flap.data\_object.DataObject method)@\spxentry{check()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{}{}
Does a consistency check for the data object and raises errors if problems found.

\end{fulllineitems}

\index{coordinate() (flap.data\_object.DataObject method)@\spxentry{coordinate()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.coordinate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{index}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns the coordinates of a subarray of the data array.
name: Coordinate name (string)
index: The indexes into the data array (tuple with various elements, see Coordinate.data())
options: The same options as for Coordinate.data()
\begin{description}
\item[{returns 3 np.arrays:}] \leavevmode\begin{description}
\item[{data: the coordinates. The number of dimension is the same as the dimension of}] \leavevmode
the data array, but the number  of elements are taken from index.

\end{description}

data\_low: low ranges, same shape as data. None if no range data is present
data\_high: high ranges, same shape as data. None if no range data is present

\end{description}

\end{fulllineitems}

\index{coordinate\_change\_dimensions() (flap.data\_object.DataObject method)@\spxentry{coordinate\_change\_dimensions()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.coordinate_change_dimensions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate\_change\_dimensions}}}{\emph{\DUrole{n}{name}}}{}
Return the list of dimensions of the data array along which
the named coordinate changes

\end{fulllineitems}

\index{coordinate\_change\_indices() (flap.data\_object.DataObject method)@\spxentry{coordinate\_change\_indices()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.coordinate_change_indices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate\_change\_indices}}}{\emph{\DUrole{n}{name}}}{}~\begin{description}
\item[{Returns the indices to the data array for which the coordinate changes.}] \leavevmode
The returned value is a tuple of indices, the number of elements equals the
dimension of the data. This can be directly used to get the coordinate values
using coordinate()

\end{description}

name: Coordinate name (string)

\end{fulllineitems}

\index{coordinate\_names() (flap.data\_object.DataObject method)@\spxentry{coordinate\_names()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.coordinate_names}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate\_names}}}{}{}
Returns a list with the coordinate names.

\end{fulllineitems}

\index{coordinate\_nochange\_dimensions() (flap.data\_object.DataObject method)@\spxentry{coordinate\_nochange\_dimensions()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.coordinate_nochange_dimensions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate\_nochange\_dimensions}}}{\emph{\DUrole{n}{name}}}{}
Return the list of dimensions of the data array along which
the named coordinate changes

\end{fulllineitems}

\index{coordinate\_range() (flap.data\_object.DataObject method)@\spxentry{coordinate\_range()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.coordinate_range}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate\_range}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{index}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}}{}
Returns the ranges of a coordinate.
name: Coordinate name (string)

Returns the data range and the data range with errors for the coordinate. Both are lists.

\end{fulllineitems}

\index{cpsd() (flap.data\_object.DataObject method)@\spxentry{cpsd()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.cpsd}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cpsd}}}{\emph{\DUrole{n}{ref}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Complex Cross Power Spectrum calculation for the data object self taking d\_ref as reference.
If self is not set d is used as reference, that is all spectra are calculated within self.
Calculates all spectra between all signals in ref and self, but not inside self and ref.
self and ref both should have the same equidistant coordinate with equal sampling points.
Returns a data object with dimension number self.dim+ref.dim\sphinxhyphen{}1. The coordinate is replaced
by frequency or wavenumber.
The spectrum is calculated in multiple intervals (described by intervals)
and the mean and variance will be returned.
\begin{description}
\item[{INPUT:}] \leavevmode
self: A flap.DataObject.
ref: Another flap.DataObject
coordinate: The name of the coordinate (string) along which to calculate CPSD.
\begin{quote}

This coordinate should change only along one data dimension and should be equidistant.
This and all other cordinates changing along the data dimension of
this coordinate will be removed. A new coordinate with name
Frequency/Wavenumber will be added. The unit will be
derived from the unit of the coordinate (e.g., Hz cm\sphinxhyphen{}1, m\sphinxhyphen{}1)
\end{quote}
\begin{description}
\item[{intervals: Information of processing intervals.}] \leavevmode\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.

\item[{options: Dictionary. (Keys can be abbreviated)}] \leavevmode\begin{description}
\item[{‘Wavenumber’}] \leavevmode{[}True/False. Will use 2*Pi*f for the output coordinate scale, this is useful for{]}
wavenumber calculation.

\end{description}

‘Resolution’: Output resolution in the unit of the output coordinate.
‘Range’: Output range in the unit of the output coordinate.
‘Logarithmic’: True/False. If True will create logarithmic frequency binning.
‘Interval\_n’: Minimum number of intervals to use for the processing. These are identical
\begin{quote}

length intervals inserted into the input interval list. Default is 8.
\end{quote}
\begin{description}
\item[{‘Error calculation’}] \leavevmode{[}True/False. Calculate or not error. Omitting error calculation{]}
increases speed. If Interval\_n is 1 no error calculation is done.

\item[{‘Trend removal’: Trend removal description (see also \_trend\_removal()). A list, string or None.}] \leavevmode\begin{quote}

None: Don’t remove trend.
Strings:
\begin{quote}

‘mean’: subtract mean
\end{quote}
\begin{description}
\item[{Lists:}] \leavevmode
{[}‘poly’, n{]}: Fit an n order polynomial to the data and subtract.

\end{description}
\end{quote}

Trend removal will be applied to each interval separately.

\end{description}

‘Hanning’: True/False Use a Hanning window.
‘Normalize’: Calculate coherency instead of crosspower

\end{description}

\end{description}

\end{fulllineitems}

\index{detrend() (flap.data\_object.DataObject method)@\spxentry{detrend()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.detrend}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{detrend}}}{\emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Trend removal.
INPUT:
\begin{quote}

coordinate: The x coordinate for the trend removal.
intervals: Information of processing intervals.
\begin{quote}
\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.
\end{quote}
\begin{description}
\item[{options:}] \leavevmode\begin{description}
\item[{‘Trend removal’: Trend removal description (see also \_trend\_removal()). A list, string or None.}] \leavevmode
None: Don’t remove trend.
Strings:
\begin{quote}

‘Mean’: subtract mean
\end{quote}
\begin{description}
\item[{Lists:}] \leavevmode\begin{description}
\item[{{[}‘Poly’, n{]}: Fit an n order polynomial to the data and subtract.}] \leavevmode
Trend removal will be applied to each interval defined by slicing
separately.

\end{description}

\end{description}

\end{description}

\end{description}
\end{quote}

Return value: The data object with the trend removed data.

\end{fulllineitems}

\index{error\_value() (flap.data\_object.DataObject method)@\spxentry{error\_value()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.error_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{error\_value}}}{\emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns a data object with the error of self in it.
options: ‘High’: Use high error if error is asymmetric
\begin{quote}

‘Low’: Use low error is error is asymmetric
\end{quote}

\end{fulllineitems}

\index{filter\_data() (flap.data\_object.DataObject method)@\spxentry{filter\_data()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.filter_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{filter\_data}}}{\emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
1D Data filter.
INPUT:
\begin{quote}

coordinate: The x coordinate for the trend removal.
intervals: Information of processing intervals.
\begin{quote}
\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.
\end{quote}
\begin{description}
\item[{options:}] \leavevmode\begin{description}
\item[{‘Type’ :}] \leavevmode
None: Do nothing.
‘Int’: Single term IIF filter, like RC integrator.
‘Diff’: Single term IIF filter, like RC differentiator.
‘Bandpass’, ‘Lowpass’, ‘Highpass’: Filters designed by scipy.signal.iirdesign.
\begin{quote}
\begin{quote}

The filter type is in ‘Design’
\end{quote}

Bandpass: f\_low \sphinxhyphen{} f\_high
Lowpass: \sphinxhyphen{} f\_high
Highpass: \sphinxhyphen{} f\_low
\end{quote}

\item[{‘Design’: The design type of the bandpass, lowpass or highpass filter.}] \leavevmode
(‘Elliptic’, ‘Butterworth, ‘Chebyshev I’, ‘Chebyshev II’, ‘Bessel’)
The numpy.iirdesign function is used for generating the filter.
Setting inconsistent parameters can cause strange results. E.g. too high attenuation
at too low frequency relative to the smapling frequency can be a problem.

\end{description}

‘f\_low’, ‘f\_high’: Cut on/off frequencies. (Middle between passband and stopband edge.)
‘Steepness’: Difference between passband and stopband edge frequencies as a fraction
\begin{quote}
\begin{quote}

of the middle frequency.
\end{quote}

‘Loss’: The maximum loss in the passband in dB
‘Attenuation’: The minimum attenuation in the stopband dB
\end{quote}

‘Tau’: time constant for integrator/differentiator (in units of the coordinate)
‘Power’: Calculate square of the signal after filtering. (boolean)
‘Inttime’: Integration time after power calculation. (in units of oordinate)

\end{description}
\end{quote}

Return value: The data object with the filtered data.

\end{fulllineitems}

\index{get\_coordinate\_object() (flap.data\_object.DataObject method)@\spxentry{get\_coordinate\_object()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.get_coordinate_object}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_coordinate\_object}}}{\emph{\DUrole{n}{name}}}{}
Returns the Coordinate class having the given name. The returned object is a link not a copy.

\end{fulllineitems}

\index{index\_from\_coordinate() (flap.data\_object.DataObject method)@\spxentry{index\_from\_coordinate()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.index_from_coordinate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{index\_from\_coordinate}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{coord\_values}}}{}~\begin{description}
\item[{Returns the closest data indices of the coordinate values.}] \leavevmode
Coordinates should change only along one dimension.
It is assumed that coordinates change monotonically.

\item[{INPUT:}] \leavevmode
name: Coordinate name (string)
coord\_values: The coordinate values to convert to indices.
\begin{quote}

(numpy array or list is scalar)
\end{quote}

\item[{Return value:}] \leavevmode
Returns the indices in the same format as the input coordinates.

\end{description}

\end{fulllineitems}

\index{plot() (flap.data\_object.DataObject method)@\spxentry{plot()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{\DUrole{n}{axes}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{slicing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{slicing\_options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{summing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_id}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Plot a data object.
axes: A list of coordinate names (strings). They should be one of the coordinate
\begin{quote}

names in the data object or ‘Data’
They describes the axes of the plot.
If the number of axes is less than the number required for the plot, ‘Data’ will be added.
If no axes are given default will be used depending on the plot type. E.g. for
x\sphinxhyphen{}y plot the default first axis is the firs coordinate, the second axis is ‘Data’
\end{quote}
\begin{description}
\item[{plot\_type: The plot type (string)}] \leavevmode
‘xy’: Simple 1D plot. Default axes are: first coordinate, Data
‘multi xy’: In case of 2D data plots 1D curves with vertical shift
\begin{quote}

Default x axis is first coordinate, y axis is Data
The signals are named in the label with the ‘Signal name’ coordinate or the one
named in options{[}‘Signal name’{]}
\end{quote}

\end{description}

plot\_options: Dictionary. Will be passed over to the plot call.
slicing, summing: arguments for slice\_data. Slicing will be applied before plotting.
options:
\begin{quote}

Matplotlib options like xtitle, xlimit, etc
Plot options:
\begin{quote}
\begin{description}
\item[{‘All points’ True or False}] \leavevmode
default is False. If True will plot all points otherwise will use
the sample\_to\_plot function

\item[{‘Error’      True: Plot all error bars (default: True)}] \leavevmode
False: Do not plot errors
number \textgreater{} 0: Plot this many error bars in plot

\item[{‘Y separation’ Vertical separation of curves in multi xy plot. For linear scale this will}] \leavevmode
be added to consecutive cureves. For Log scale consecutive curves will be
multiplied by this.

\end{description}

‘Log x’ : Logscale X axis
‘Log y’ : Logscale Y axis
\end{quote}
\end{quote}

\end{fulllineitems}

\index{proc\_interval\_limits() (flap.data\_object.DataObject method)@\spxentry{proc\_interval\_limits()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.proc_interval_limits}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{proc\_interval\_limits}}}{\emph{\DUrole{n}{coordinate}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Determine processing interval limits, both in coordinates and data indices.
This is a helper routine for all functions which do some calculation as a function
of one coordinate and allow processing only a set of intervals instead of the whole dataset.
INPUT:
\begin{quote}
\begin{description}
\item[{coordinate: Name of the coordinate along which calculation will be done. This must}] \leavevmode
change only along a single data dimension.

\item[{intervals: Information of processing intervals.}] \leavevmode\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.

\end{description}
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
calc\_int, calc\_int\_ind, sel\_int, sel\_int\_ind
Each return value is a list of numpy arrays: {[}start, end{]}
The calc\_xxx values are for the calculation coordinate, the sel\_xxx are for the
selection coordinate. xxx\_int is in coordinate values, xxx\_int\_ind is in data index
values which follows the Python convention, end index is not included.
The index start indices will be always smaller than the end indices.

\end{description}

\end{fulllineitems}

\index{save() (flap.data\_object.DataObject method)@\spxentry{save()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{protocol}\DUrole{o}{=}\DUrole{default_value}{3}}}{}
Save the data object to a binary file using pickle.
Use load to read the object.
Filename: The name of the output file
protocol: The pickle protocol to use

\end{fulllineitems}

\index{slice\_data() (flap.data\_object.DataObject method)@\spxentry{slice\_data()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.slice_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{slice\_data}}}{\emph{\DUrole{n}{slicing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{summing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Slice (select areas) from the data object along one or more coordinates.
Return the sliced object.
\begin{quote}
\begin{description}
\item[{slicing:}] \leavevmode\begin{description}
\item[{Dictionary with keys referring to coordinates in the data object.}] \leavevmode\begin{description}
\item[{Values can be:}] \leavevmode\begin{description}
\item[{a:SIMPLE SLICE: cases when closest value or interpolated value is selected.}] \leavevmode
a1 slice objects, range objects, scalars, lists, numpy array.
a2 flap.DataObjects without error and with data unit.name equal to
\begin{quote}

the coordinate
\end{quote}
\begin{description}
\item[{a3 flap.DataObject with the name of one coordinate equal to the dictionary}] \leavevmode
key without having value\_ranges values.

\end{description}

a4 flap.Intervals objects with one interval

\item[{b: MULTI SLICE: Various range selection objects. In this case ranges are}] \leavevmode
selected and a new dimension is added to the data array
(only of more than 1 interval is selected) going through the
intervals. If intervals are of different length the longest will be used
and missing elements filled with float(‘nan’).
Two new coordinates are added: “\textless{}coordinate\textgreater{} in interval”,
“\textless{}coordinate\textgreater{} interval”
b1 flap.Intervals objects with more than one interval
b2 flap.DataObjects with data unit.name equal to the slicing coordinate. The error
\begin{quote}

values give the intervals.
\end{quote}
\begin{description}
\item[{b3 flap.DataObject with the name of one coordinate equal to the slicing coordinate.}] \leavevmode
The value\_ranges select the intervals.

\end{description}

If range slicing is done with multiple coordinates which have common element in the
dimension list they will be done in one step. Otherwise the slicing is done sequentially.

\end{description}

\end{description}

\end{description}

\item[{summing:}] \leavevmode
Summing is applied to the sliced data. It processes data along one coordinate
and the result is a scalar. This way summing reduces the number of dimensions.
Dictionary with keys referring to coordinates and values as processing strings. If
the processed coordinate changes along multiple dimensions those dimensions will be flattened.

For mean and avereage data errors are calculated as error of independent variables, that is taking the square
root of the squared sum of errors. For coordinates the mean of the ranges is taken.
\begin{description}
\item[{Processing strings are the following:}] \leavevmode\begin{quote}

None: Nothing to be done in this dimension
\end{quote}

‘Mean’ : take mean of values in selection/coordinate
‘Sum’  : take sum of values in selection/coordinate
‘Min’  : take the minimum of the values/coordinate
‘Max’  : take the maximum of the values/coordinate

\end{description}

\item[{options: ‘Partial intervals’  (bool). If true processes intervals which extend over the coordinate limits.}] \leavevmode\begin{quote}

If false only full intervals are processed.
\end{quote}
\begin{description}
\item[{‘Slice type’: ‘Simple’: Case a above: closest or interpolated values are selected, dimensions}] \leavevmode\begin{quote}

are reduced or unchanged.
\end{quote}
\begin{description}
\item[{‘Multi’: Case b above: multiple intervals are selected and their data is placed into}] \leavevmode
new dimension.

\end{description}

None: Automatically select. For slicing data in case b multi slice, otherwise simple

\item[{‘Interpolation: ‘Closest value’}] \leavevmode
‘Linear’

\item[{‘Regenerate coordinates’: True/False  (defaultL True)}] \leavevmode
If True and summing is done then looks for pairs of coordinates
‘Rel. \textless{}coord\textgreater{} in int(\textless{}coord1\textgreater{})’  ‘Start \textless{}coord\textgreater{} in int(\textless{}coord1\textgreater{})’.
If such pairs are found and they change on the same dimension or one of them is constant then
coordinate \textless{}coord\textgreater{} is regenerated and these are removed.

\end{description}

\end{description}
\end{quote}

\end{fulllineitems}

\index{slicing\_to\_intervals() (flap.data\_object.DataObject method)@\spxentry{slicing\_to\_intervals()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.slicing_to_intervals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{slicing\_to\_intervals}}}{\emph{\DUrole{n}{slicing}}}{}
Convert a multi\sphinxhyphen{}slicing description to an Intervals object.
For possibilities see DataObject.slice\_data().

\end{fulllineitems}

\index{to\_intervals() (flap.data\_object.DataObject method)@\spxentry{to\_intervals()}\spxextra{flap.data\_object.DataObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.DataObject.to_intervals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_intervals}}}{\emph{\DUrole{n}{coordinate}}}{}
Create an Intervals class object from either the data error ranges or
the coordinate value ranges.

\end{fulllineitems}


\end{fulllineitems}

\index{FlapStorage (class in flap.data\_object)@\spxentry{FlapStorage}\spxextra{class in flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.FlapStorage}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{FlapStorage}}}
This class is for data and data source information storage
\index{find\_data\_objects() (flap.data\_object.FlapStorage method)@\spxentry{find\_data\_objects()}\spxextra{flap.data\_object.FlapStorage method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.FlapStorage.find_data_objects}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find\_data\_objects}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}}{}
”
Find data objects in flap storage.

Returns name list, exp\_ID list

\end{fulllineitems}


\end{fulllineitems}

\index{abs\_value() (in module flap.data\_object)@\spxentry{abs\_value()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.abs_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{abs\_value}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Absolute value

\end{fulllineitems}

\index{add\_coordinate() (in module flap.data\_object)@\spxentry{add\_coordinate()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.add_coordinate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{add\_coordinate}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{coordinates}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This is the function to add coordinates to a data object in flap storage.
This function is an interface to the add\_coordinate method of flap.DataObject
\begin{description}
\item[{INPUT:}] \leavevmode
object\_name, exp\_ID: These identify the data object in the storage
coordinates: List of new coordinates (string list)
output\_name: The name of the new data object in the storage. If None
\begin{quote}

the input will be overwritten
\end{quote}
\begin{description}
\item[{options: Dictionary}] \leavevmode\begin{description}
\item[{‘exp\_ID’: Use this exp\_id for calculating coordinates instead of the one}] \leavevmode
in the data object

\item[{‘data\_source’}] \leavevmode{[}Use this data source instead of the one in the{]}
data object.

\end{description}

Other elements of options are passed over to flap.add\_coordinate()

\end{description}

\end{description}

\end{fulllineitems}

\index{add\_data\_object() (in module flap.data\_object)@\spxentry{add\_data\_object()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.add_data_object}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{add\_data\_object}}}{\emph{\DUrole{n}{d}}, \emph{\DUrole{n}{object\_name}}}{}
Add a data object to the flap storage

\end{fulllineitems}

\index{apsd() (in module flap.data\_object)@\spxentry{apsd()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.apsd}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{apsd}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Auto Power Spetctrum for an object in flap storage. This is a wrapper for DataObject.apsd()
If output name is set the APSD object will be written back to the flap storage under this name.
If not set the APSD object will be written back with its original name.

\end{fulllineitems}

\index{ccf() (in module flap.data\_object)@\spxentry{ccf()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.ccf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{ccf}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{ref}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{ref\_exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Cross Corrrelation Function or covariance calculation between two objects in flap storage.
This is a wrapper for DataObject.ccf()
If output name is set the CPSD object will be written back to the flap storage under this name.

\end{fulllineitems}

\index{cpsd() (in module flap.data\_object)@\spxentry{cpsd()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.cpsd}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{cpsd}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{ref}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Cross Power Spectrum between two objects in flap storage. (ref can also be a data object.)
This is a wrapper for DataObject.cpsd()
If output name is set the CPSD object will be written back to the flap storage under this name.

\end{fulllineitems}

\index{delete\_data\_object() (in module flap.data\_object)@\spxentry{delete\_data\_object()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.delete_data_object}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{delete\_data\_object}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}}{}
Delete data object(s) from the flap storage

\end{fulllineitems}

\index{detrend() (in module flap.data\_object)@\spxentry{detrend()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.detrend}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{detrend}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
DETREND signal(s)
INPUT:
\begin{quote}

object\_name: Name of the object in flap storage (string)
exp\_id: Experiment ID
output\_name: Name of the output object. If set result will be  stored under this name.
coordinate: The coordinate for the detrend. If necessary data will be fitted with this coordinate
\begin{quote}

as x value.
\end{quote}
\begin{description}
\item[{intervals: Information of processing intervals.}] \leavevmode\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.

\item[{options:}] \leavevmode\begin{description}
\item[{‘Trend removal’: Trend removal description (see also \_trend\_removal()). A list, string or None.}] \leavevmode
None: Don’t remove trend.
Strings:
\begin{quote}

‘mean’: subtract mean
\end{quote}
\begin{description}
\item[{Lists:}] \leavevmode\begin{description}
\item[{{[}‘poly’, n{]}: Fit an n order polynomial to the data and subtract.}] \leavevmode
Trend removal will be applied to each interval defined by slicing
separately.

\end{description}

\end{description}

\end{description}

\end{description}
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
The resulting data object.

\end{description}

\end{fulllineitems}

\index{error\_value() (in module flap.data\_object)@\spxentry{error\_value()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.error_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{error\_value}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns a data object with the error of self in it.
options: ‘High’: Use high error if error is asymmetric
\begin{quote}

‘Low’: Use low error is error is asymmetric
\end{quote}

\end{fulllineitems}

\index{filter\_data() (in module flap.data\_object)@\spxentry{filter\_data()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.filter_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{filter\_data}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
1D Data filter.
INPUT:
\begin{quote}

object\_name: Name of the object in flap storage (string)
exp\_id: Experiment ID
output\_name: Name of the output object. If not set object\_name will be used.
coordinate: The x coordinate for the trend removal.
intervals: Information of processing intervals.
\begin{quote}
\begin{quote}
\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None is is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.
\end{quote}
\begin{description}
\item[{options:}] \leavevmode\begin{description}
\item[{‘Type’ :}] \leavevmode
None: Do nothing.
‘Int’: Single term IIF filter, like RC integrator.
‘Diff’: Single term IIF filter, like RC differentiator.
‘Bandpass’, ‘Lowpass’, ‘Highpass’: Filters designed by scipy.signal.iirdesign.
\begin{quote}
\begin{quote}

The filter type is in ‘Design’
\end{quote}

Bandpass: f\_low \sphinxhyphen{} f\_high
Lowpass: \sphinxhyphen{} f\_high
Highpass: \sphinxhyphen{} f\_low
\end{quote}

\item[{‘Design’: The design type of the bandpass, lowpass or highpass filter.}] \leavevmode
(‘Elliptic’, ‘Butterworth, ‘Chebyshev I’, ‘Chebyshev II’, ‘Bessel’)
The numpy.iirdesign function is used for generating the filter.
Setting inconsistent parameters can cause strange results. E.g. too high attenuation
at too low frequency relative to the smapling frequency can be a problem.

\end{description}

‘f\_low’, ‘f\_high’: Cut on/off frequencies. (Middle between passband and stopband edge.)
‘Steepness’: Difference between passband and stopband edge frequencies as a fraction
\begin{quote}
\begin{quote}

of the middle frequency.
\end{quote}

‘Loss’: The maximum loss in the passband in dB
‘Attenuation’: The minimum attenuation in the stopband dB
\end{quote}

‘Tau’: time constant for integrator/differentiator (in units of the coordinate)
‘Power’: Calculate square of the signal after filtering. (boolean)
‘Inttime’: Integration time after power calculation. (in units of oordinate)    Return value: The data object with the filtered data.

\end{description}
\end{quote}
\end{quote}

\end{fulllineitems}

\index{find\_data\_objects() (in module flap.data\_object)@\spxentry{find\_data\_objects()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.find_data_objects}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{find\_data\_objects}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}}{}
Find data objects in flap storage.

Returns list of names, list of expID.s

\end{fulllineitems}

\index{get\_addcoord\_function() (in module flap.data\_object)@\spxentry{get\_addcoord\_function()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.get_addcoord_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{get\_addcoord\_function}}}{\emph{\DUrole{n}{data\_source}}}{}
Return the add\_coord function object for a given data source

\end{fulllineitems}

\index{get\_data() (in module flap.data\_object)@\spxentry{get\_data()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.get_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{get\_data}}}{\emph{\DUrole{n}{data\_source}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{no\_data}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coordinates}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{object\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This is a general data read interface. It will call the specific data read interface
for the registered data sources.
data\_source: The name of the data source (string)
exp\_id: Experiment ID
coordinates: Two options:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
List of flap.Coordinate objects. Thes can precisely describe which part of the data to read

\item {} \begin{description}
\item[{Dictionary. Each key is a coordinate name, the values can be}] \leavevmode\begin{itemize}
\item {} 
A list of two elements (describes a range in the coordinate).

\item {} 
A single element. Will be converted into a list with two identical elements

\end{itemize}

\end{description}

The dictionary will be converted to a list of flap.Coordinate objects and
the data source modulee will get that.

\end{enumerate}

name: The name of the data to get
no\_data: Set to True to check data but do not read
options: Module specific options
object\_name: the name of the data object in flap storage where data will be placed.

Return value is the data object.

\end{fulllineitems}

\index{get\_data\_function() (in module flap.data\_object)@\spxentry{get\_data\_function()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.get_data_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{get\_data\_function}}}{\emph{\DUrole{n}{data\_source}}}{}
Return the get data function object for a given data source

\end{fulllineitems}

\index{get\_data\_object() (in module flap.data\_object)@\spxentry{get\_data\_object()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.get_data_object}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{get\_data\_object}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}}{}
Return a data object from the flap storage
A coppy is returned not the object in the storage.

\end{fulllineitems}

\index{get\_data\_object\_ref() (in module flap.data\_object)@\spxentry{get\_data\_object\_ref()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.get_data_object_ref}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{get\_data\_object\_ref}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}}{}
Return a data object reference from the flap storage.

\end{fulllineitems}

\index{imag() (in module flap.data\_object)@\spxentry{imag()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.imag}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{imag}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Real value. (Does nothing for real data)

\end{fulllineitems}

\index{list\_data\_objects() (in module flap.data\_object)@\spxentry{list\_data\_objects()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.list_data_objects}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{list\_data\_objects}}}{\emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{screen}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Prepare a printout of data objects is flap storage or the listed data objects.
name: name (with wildcards) or list of data objects
exp\_id: exp id for name
screen: (bool) If True print to screen

Return value: The text

\end{fulllineitems}

\index{list\_data\_sources() (in module flap.data\_object)@\spxentry{list\_data\_sources()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.list_data_sources}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{list\_data\_sources}}}{}{}
Return a list of registered data source names as a list.

\end{fulllineitems}

\index{load() (in module flap.data\_object)@\spxentry{load()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.load}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Loads data saved with flap.save()
If the data in the file were written from the flap storage it will also be
loaded there, unless  no\_storage is set to True.
\begin{description}
\item[{INPUT:}] \leavevmode
filename: Name of the file to read.
options: “No storage”: (bool) If True don’t store data in flap storage just return a list of them.

\item[{Return value:}] \leavevmode
If data was not written from flap storage the original object will be returned.
If it was written out from flap storage a list of the read objects will be returned..

\end{description}

\end{fulllineitems}

\index{phase() (in module flap.data\_object)@\spxentry{phase()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.phase}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{phase}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Phase

\end{fulllineitems}

\index{plot() (in module flap.data\_object)@\spxentry{plot()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{plot}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{axes}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{slicing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{summing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_id}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{slicing\_options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
plot function for an object in flap storage. This is a wrapper for DataObject.plot()

\end{fulllineitems}

\index{real() (in module flap.data\_object)@\spxentry{real()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.real}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{real}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Real value. (Does nothing for real data)

\end{fulllineitems}

\index{register\_data\_source() (in module flap.data\_object)@\spxentry{register\_data\_source()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.register_data_source}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{register\_data\_source}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{get\_data\_func}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{add\_coord\_func}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Register a new data source name and the associated functions.

\end{fulllineitems}

\index{save() (in module flap.data\_object)@\spxentry{save()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.save}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{protocol}\DUrole{o}{=}\DUrole{default_value}{3}}}{}
Save one or more flap.DataObject\sphinxhyphen{}s using pickle.
\begin{description}
\item[{INPUT:}] \leavevmode\begin{description}
\item[{data: If flap.DataObject than save this.}] \leavevmode
If string or string list then find these data objects in flap storage and save them.
Will also use exp\_id to select data objects. These data objects can be restored
into flap storage using load.
If any other object save it.

\end{description}

exp\_id: Experiment ID to use in conjuction with data of it is a string.
options: None at present
protocol: The protocol to use
filename: Name of the file to save to.

\end{description}

\end{fulllineitems}

\index{slice\_data() (in module flap.data\_object)@\spxentry{slice\_data()}\spxextra{in module flap.data\_object}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_object:flap.data_object.slice_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.data\_object.}}\sphinxbfcode{\sphinxupquote{slice\_data}}}{\emph{\DUrole{n}{object\_name}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{slicing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{summing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
slice function for an object in flap storage. This is a wrapper for DataObject.slicec\_data()
If output name is set the sliced object will be written back to the flap storage under this name.

\end{fulllineitems}



\section{Plot}
\label{\detokenize{plot:module-flap.plot}}\label{\detokenize{plot:plot}}\label{\detokenize{plot::doc}}\index{module@\spxentry{module}!flap.plot@\spxentry{flap.plot}}\index{flap.plot@\spxentry{flap.plot}!module@\spxentry{module}}
Created on Sat May 18 18:37:06 2019

@author: Zoletnik
@coauthor: Lampert
\index{PddType (class in flap.plot)@\spxentry{PddType}\spxextra{class in flap.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:flap.plot.PddType}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.plot.}}\sphinxbfcode{\sphinxupquote{PddType}}}{\emph{\DUrole{n}{value}}}{}
An enumeration.

\end{fulllineitems}

\index{PlotDataDescription (class in flap.plot)@\spxentry{PlotDataDescription}\spxextra{class in flap.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:flap.plot.PlotDataDescription}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{flap.plot.}}\sphinxbfcode{\sphinxupquote{PlotDataDescription}}}{\emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_object}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Plot axis description for use in PlotID() and plot().
data\_object: The data object from which the data for this coordinate originates. This may
\begin{quote}

be None if the data is constant.
\end{quote}
\begin{description}
\item[{data\_type: PddType}] \leavevmode\begin{description}
\item[{PddType.Coordinate: A coordinate in data\_object.}] \leavevmode
self.value is a flap.Coordinate object.

\end{description}

PddType.Constant: A float constant, stored in value.
PddType.Data: The data in self.data\_object.

\end{description}

value: Value, see above

\end{fulllineitems}

\index{axes\_to\_pdd\_list() (in module flap.plot)@\spxentry{axes\_to\_pdd\_list()}\spxextra{in module flap.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:flap.plot.axes_to_pdd_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.plot.}}\sphinxbfcode{\sphinxupquote{axes\_to\_pdd\_list}}}{\emph{\DUrole{n}{d}}, \emph{\DUrole{n}{axes}}}{}
Convert a plot() axes parameter to a list of PlotAxisDescription and axes list for PlotID
d: data object
axes: axes parameter of plot()

return pdd\_list, ax\_list

\end{fulllineitems}

\index{get\_plot\_id() (in module flap.plot)@\spxentry{get\_plot\_id()}\spxextra{in module flap.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:flap.plot.get_plot_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.plot.}}\sphinxbfcode{\sphinxupquote{get\_plot\_id}}}{}{}
Return the current PlotID or None if no act plot.

\end{fulllineitems}

\index{sample\_for\_plot() (in module flap.plot)@\spxentry{sample\_for\_plot()}\spxextra{in module flap.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:flap.plot.sample_for_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.plot.}}\sphinxbfcode{\sphinxupquote{sample\_for\_plot}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{x\_error}}, \emph{\DUrole{n}{y\_error}}, \emph{\DUrole{n}{n\_points}}}{}
Resamples the y(x) function to np points for plotting.
This is useful for plotting large arrays in a way that short outlier pulses
are still indicated.
The original function is divided into np equal size blocks in x and in each block
the minimum and maximum is determined. The output will contain 2*np number
or points. Each consecutive point pair contains the minimum and maximum in
a block, the time is the centre time of the block.

x: Input x array.
y: input y array.
np: Desired number of blocks. This would be a number larger than the number
\begin{quote}

of pixels in the plot in the horizontal direction.
\end{quote}
\begin{description}
\item[{Return values:}] \leavevmode
x\_out, y\_out
If the box length is less than 5 the original data will be returned.

\end{description}

\end{fulllineitems}

\index{set\_plot\_id() (in module flap.plot)@\spxentry{set\_plot\_id()}\spxextra{in module flap.plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:flap.plot.set_plot_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.plot.}}\sphinxbfcode{\sphinxupquote{set\_plot\_id}}}{\emph{\DUrole{n}{plot\_id}}}{}
Set the current plot.

\end{fulllineitems}



\section{Select}
\label{\detokenize{select:module-flap.select}}\label{\detokenize{select:select}}\label{\detokenize{select::doc}}\index{module@\spxentry{module}!flap.select@\spxentry{flap.select}}\index{flap.select@\spxentry{flap.select}!module@\spxentry{module}}
Created on Fri Apr 12 19:23:25 2019

@author: Zoletnik
\index{select\_intervals() (in module flap.select)@\spxentry{select\_intervals()}\spxextra{in module flap.select}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{select:flap.select.select_intervals}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.select.}}\sphinxbfcode{\sphinxupquote{select\_intervals}}}{\emph{\DUrole{n}{object\_descr}}, \emph{\DUrole{n}{coordinate}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exp\_id}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}*\textquotesingle{}}}, \emph{\DUrole{n}{intervals}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Select intervals from data interactively.
INPUT:
\begin{quote}
\begin{description}
\item[{object\_descr: If a data object: Plot this data object to select.}] \leavevmode
String: Will be interpreted as a data object name in flap storage.

\item[{exp\_id: The exp\_id if dobject\_descr is a string}] \leavevmode\begin{description}
\item[{intervals: Information of processing intervals.}] \leavevmode\begin{description}
\item[{If dictionary with a single key: \{selection coordinate: description\})}] \leavevmode
Key is a coordinate name which can be different from the calculation
coordinate.
Description can be flap.Intervals, flap.DataObject or
a list of two numbers. If it is a data object with data name identical to
the coordinate the error ranges of the data object will be used for
interval. If the data name is not the same as coordinate a coordinate with the
same name will be searched for in the data object and the value\_ranges
will be used fromm it to set the intervals.

\item[{If not a dictionary and not None it is interpreted as the interval}] \leavevmode
description, the selection coordinate is taken the same as
coordinate.

\end{description}

If None, the whole data interval will be used as a single interval.

\end{description}

\item[{coordinate: The name of the coordinate to use for x axis. (string) This will be the}] \leavevmode
coordinate of the selection.

\end{description}

plot\_options: Passed to plot().
options: Dictionary of options:
\begin{quote}
\begin{description}
\item[{‘Select’: ‘Start’: Select start of intervals. (Needs Lenght to be set.)}] \leavevmode
‘End’: Select end of intervals. (Needs Lenght to be set.)
‘Full’: Select start and end of interval.
‘Center’: Select center of interval.
None: No interactive selection

\end{description}

‘Length’: Length of intervals.
‘Event’ : Dictionary describing events to search for. A reference time will be
\begin{quote}

determined for each event and a Length interval will be selected
symmetrically around it. Trend removal and/or filtering should be done
before calling this function.
‘Type’: ‘Maximum’ or ‘Minimum’:
\begin{quote}
\begin{quote}

Will look for signal pieces above/below threshold
and calculate maximum place of signal in this piece.
\end{quote}
\begin{description}
\item[{‘Max\sphinxhyphen{}weight’ or ‘Min\sphinxhyphen{}weight’:}] \leavevmode
Same as Maximum and Minimum but selects center of gravity
for signal piece.

\end{description}

In each of the above cases the interval will be ‘Length’ long around the event.
‘Above’, ‘Below’:
\begin{quote}

The intervals will be where the signal is above or below the threshold.
\end{quote}
\end{quote}
\begin{description}
\item[{‘Start delay’, ‘End delay’: For the Above and Below events the start and end delay of the interval}] \leavevmode
in the coordinate units.

\end{description}

‘Threshold’: The threshold for the event.
‘Thr\sphinxhyphen{}type’ Threshold type:
\begin{quote}

‘Absolute’: Absolute signal value
‘Sigma’: Threshold times sigma
\end{quote}
\end{quote}
\end{quote}

output\_name: Output object name in flap storage.
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
A data object. Data name is the coordinate name. The error gives the intervals.

\end{description}

\end{fulllineitems}



\section{Spectral analysis}
\label{\detokenize{spectral_analysis:module-flap.spectral_analysis}}\label{\detokenize{spectral_analysis:spectral-analysis}}\label{\detokenize{spectral_analysis::doc}}\index{module@\spxentry{module}!flap.spectral\_analysis@\spxentry{flap.spectral\_analysis}}\index{flap.spectral\_analysis@\spxentry{flap.spectral\_analysis}!module@\spxentry{module}}
Created on Thu Mar  7 10:34:49 2019

@author: Zoletnik

Spectral analysis tools fro FLAP
\index{trend\_removal\_func() (in module flap.spectral\_analysis)@\spxentry{trend\_removal\_func()}\spxextra{in module flap.spectral\_analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spectral_analysis:flap.spectral_analysis.trend_removal_func}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.spectral\_analysis.}}\sphinxbfcode{\sphinxupquote{trend\_removal\_func}}}{\emph{\DUrole{n}{d}}, \emph{\DUrole{n}{ax}}, \emph{\DUrole{n}{trend}}, \emph{\DUrole{n}{x}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{return\_trend}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{return\_poly}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
This function makes the \_trend\_removal internal function public

\end{fulllineitems}



\section{Test data}
\label{\detokenize{test_data:test-data}}\label{\detokenize{test_data::doc}}

\section{Tools}
\label{\detokenize{tools:module-flap.tools}}\label{\detokenize{tools:tools}}\label{\detokenize{tools::doc}}\index{module@\spxentry{module}!flap.tools@\spxentry{flap.tools}}\index{flap.tools@\spxentry{flap.tools}!module@\spxentry{module}}
Created on Wed Jan 23 13:18:25 2019

@author: Zoletnik

Tools for the FLAP module
\index{chlist() (in module flap.tools)@\spxentry{chlist()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.chlist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{chlist}}}{\emph{\DUrole{n}{chlist}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{chrange}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{prefix}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{postfix}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
Creates a channel (signal) list name from a prefix, postfix a channel list and a list of channel
ranges

\end{fulllineitems}

\index{del\_list\_elements() (in module flap.tools)@\spxentry{del\_list\_elements()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.del_list_elements}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{del\_list\_elements}}}{\emph{\DUrole{n}{input\_list}}, \emph{\DUrole{n}{indices}}}{}
delete elements from a list

\end{fulllineitems}

\index{expand\_matrix() (in module flap.tools)@\spxentry{expand\_matrix()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.expand_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{expand\_matrix}}}{\emph{\DUrole{n}{mx}}, \emph{\DUrole{n}{new\_shape}}, \emph{\DUrole{n}{dim\_list}}}{}
Insert new dimensions to a matrix so as it has \textless{}new shape\textgreater{} shape.
The original dimensions are at dim\_list dimensions
\begin{description}
\item[{Input:}] \leavevmode
mx: The matrix with arbitrary dimensions.
new\_shape: This will be the new shape
dim\_list: This is a list of dimensions where mx is in the output
\begin{quote}

matrix. len(dim\_list) == mx.ndim
\end{quote}

\end{description}

\end{fulllineitems}

\index{find\_str\_match() (in module flap.tools)@\spxentry{find\_str\_match()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.find_str_match}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{find\_str\_match}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{options}}}{}
Given value string and a list of possibilities in the list of strings option
find matches assuming value is an abbreviation. Return ValueError if no match
or multiple match is found.
If one match is found return the matching string

\end{fulllineitems}

\index{flatten\_multidim() (in module flap.tools)@\spxentry{flatten\_multidim()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.flatten_multidim}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{flatten\_multidim}}}{\emph{\DUrole{n}{mx}}, \emph{\DUrole{n}{dim\_list}}}{}
Flatten the dimensions in dim\_list to dim\_list{[}0{]}
Returns the modified matrix and a mapping from the original to the new dimension list.
The mapping will be None for the flattened dimension in dim\_list even if
flattening was not done. The dimension numbers in the dimension list assume that
the flattened dimensions are removed.

\end{fulllineitems}

\index{grid\_to\_box() (in module flap.tools)@\spxentry{grid\_to\_box()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.grid_to_box}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{grid\_to\_box}}}{\emph{\DUrole{n}{xdata}}, \emph{\DUrole{n}{ydata}}}{}
Given 2D x and y coordinate matrices create box coordinates around the points as
needed by matplotlib.pcolomesh.
xdata: X coordinates.
ydata: Y coordinates.
In both arrays x direction is along first dimension, y direction along second dimension.
Returns xbox, ybox.

\end{fulllineitems}

\index{move\_axes\_to\_end() (in module flap.tools)@\spxentry{move\_axes\_to\_end()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.move_axes_to_end}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{move\_axes\_to\_end}}}{\emph{\DUrole{n}{mx\_orig}}, \emph{\DUrole{n}{axes}}}{}
Moves the listed axes to the end.

\end{fulllineitems}

\index{move\_axes\_to\_start() (in module flap.tools)@\spxentry{move\_axes\_to\_start()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.move_axes_to_start}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{move\_axes\_to\_start}}}{\emph{\DUrole{n}{mx\_orig}}, \emph{\DUrole{n}{axes}}}{}
Moves the listed axes to the start axes.

\end{fulllineitems}

\index{multiply\_along\_axes() (in module flap.tools)@\spxentry{multiply\_along\_axes()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.multiply_along_axes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{multiply\_along\_axes}}}{\emph{\DUrole{n}{a1\_orig}}, \emph{\DUrole{n}{a2\_orig}}, \emph{\DUrole{n}{axes}}, \emph{\DUrole{n}{keep\_a1\_dims}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Multiplies two arrays along given axes.
INPUT:
\begin{quote}

a1\_orig: Array 1.
a2\_orig: Array 2.
axes: List of two axis numbers or list of two lists of axis numbers
keep\_1\_dims: (bool)
\begin{quote}

If True: The output array has dimensions of a1 followed by a2 with the common dims removed
If False: The output array has the a1 dimensions without common dims then the common dims
\begin{quote}

followed by a2 with the common dims removed
\end{quote}
\end{quote}
\end{quote}
\begin{description}
\item[{Return values:}] \leavevmode\begin{description}
\item[{a, axis\_source, axis\_number}] \leavevmode
a: An array with dimension number a1.dim+a2.dim\sphinxhyphen{}1.
axis\_source: List of integers telling the source array for each output axis ( 0 or 1)
axis\_number: Axis numbers in the arrays listed in axes\_source

\end{description}

\end{description}

\end{fulllineitems}

\index{select\_signals() (in module flap.tools)@\spxentry{select\_signals()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.select_signals}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{select\_signals}}}{\emph{\DUrole{n}{signal\_list}}, \emph{\DUrole{n}{signal\_spec}}}{}
Selects signals from a signal list following signal specifications.

signal\_list: List of strings of possible signal names
\begin{description}
\item[{signal\_spec: List of strings with signal specifications including wildcards}] \leavevmode
Normal Unix file name wildcards are accepted and extended with
{[}\textless{}num\textgreater{}\sphinxhyphen{}\textless{}num\textgreater{}{]} type expressions so as e.g. a channel range can be selected.

\item[{Returs select\_list, select\_index}] \leavevmode
select\_list: List of strings with selected signal names
select\_index: List of indices to signal list of the selected signals

\end{description}

Raises ValueError if there is no match for one specification

\end{fulllineitems}

\index{submatrix\_index() (in module flap.tools)@\spxentry{submatrix\_index()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.submatrix_index}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{submatrix\_index}}}{\emph{\DUrole{n}{mx\_shape}}, \emph{\DUrole{n}{index}}}{}~\begin{description}
\item[{Given an arbitrary dimension matrix with shape mx\_shape the tuple to}] \leavevmode
extract a submatrix is created and returned.
The elements in each dimension are selected by index.

\item[{Input:}] \leavevmode
mx\_shape: Shape of the matrix
index: Tuple or list of 1D numpy arrays. The length should be equal to the
length of mx\_shape. Each array contains the indices for the
\begin{quote}

corresponding dimension.
\end{quote}

\item[{Return value:}] \leavevmode
A tuple of index matrices. Each index matrix has the same shape as
described by index. Each matrix contains the indices for one dimension
of the matrix. This tuple can be directly used for indexing the matrix.

\end{description}

\end{fulllineitems}

\index{unify\_list() (in module flap.tools)@\spxentry{unify\_list()}\spxextra{in module flap.tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tools:flap.tools.unify_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{flap.tools.}}\sphinxbfcode{\sphinxupquote{unify\_list}}}{\emph{\DUrole{n}{list1}}, \emph{\DUrole{n}{list2}}}{}
Returns list with elements present in any of the two lists.
Output list is sorted.

\end{fulllineitems}



\chapter{Usage of FLAP (tips/tricks/faq)}
\label{\detokenize{usage:usage-of-flap-tips-tricks-faq}}\label{\detokenize{usage::doc}}
This page contains all the techniques the FLAP developers or other FLAP
users find useful for newcomers and even experienced FLAP users.

Contents


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{f}
\item\relax\sphinxstyleindexentry{flap.config}\sphinxstyleindexpageref{config:\detokenize{module-flap.config}}
\item\relax\sphinxstyleindexentry{flap.coordinate}\sphinxstyleindexpageref{coordinate:\detokenize{module-flap.coordinate}}
\item\relax\sphinxstyleindexentry{flap.data\_object}\sphinxstyleindexpageref{data_object:\detokenize{module-flap.data_object}}
\item\relax\sphinxstyleindexentry{flap.plot}\sphinxstyleindexpageref{plot:\detokenize{module-flap.plot}}
\item\relax\sphinxstyleindexentry{flap.select}\sphinxstyleindexpageref{select:\detokenize{module-flap.select}}
\item\relax\sphinxstyleindexentry{flap.spectral\_analysis}\sphinxstyleindexpageref{spectral_analysis:\detokenize{module-flap.spectral_analysis}}
\item\relax\sphinxstyleindexentry{flap.tools}\sphinxstyleindexpageref{tools:\detokenize{module-flap.tools}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}