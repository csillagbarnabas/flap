
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>flap.spectral_analysis &#8212; FLAP  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for flap.spectral_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Thu Mar  7 10:34:49 2019</span>

<span class="sd">@author: Zoletnik</span>

<span class="sd">Spectral analysis tools fro FLAP</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">flap.config</span>
<span class="kn">import</span> <span class="nn">flap.coordinate</span>
<span class="c1">#from .coordinate import *</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="c1">#import matplotlib.pyplot as plt</span>

<span class="k">def</span> <span class="nf">_spectral_calc_interval_selection</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span><span class="n">intervals</span><span class="p">,</span><span class="n">interval_n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Helper function for spectral and correlation calculation.</span>
<span class="sd">        Determines the processing intervals and returns in a</span>
<span class="sd">        flap.Intervals object. The intervals will have identical length.</span>

<span class="sd">        INPUT:</span>
<span class="sd">            d, ref: flap.DataObjects</span>
<span class="sd">            If ref is set it is assumed that the selection coordinate step size is identical in d and ref.</span>
<span class="sd">            coordinate: Coordinate name (string)</span>
<span class="sd">            intervals: Information of processing intervals.</span>
<span class="sd">                       If dictionary with a single key: {selection coordinate: description})</span>
<span class="sd">                           Key is a coordinate name which can be different from the calculation</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                           Description can be flap.Intervals, flap.DataObject or</span>
<span class="sd">                           a list of two numbers. If it is a data object with data name identical to</span>
<span class="sd">                           the coordinate the error ranges of the data object will be used for</span>
<span class="sd">                           interval. If the data name is not the same as coordinate a coordinate with the</span>
<span class="sd">                           same name will be searched for in the data object and the value_ranges</span>
<span class="sd">                           will be used fromm it to set the intervals.</span>
<span class="sd">                       If not a dictionary and not None is is interpreted as the interval</span>
<span class="sd">                           description, the selection coordinate is taken the same as</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                       If None, the whole data interval will be used as a single interval.</span>
<span class="sd">            interval_n: Minimum number of intervals to use for the processing. These are identical</span>
<span class="sd">                        length intervals inserted into the input interval list.</span>
<span class="sd">        Returns:</span>
<span class="sd">            intervals, index_intervals</span>
<span class="sd">                intervals: The intervals in the coordinate unit (Intervals object)</span>
<span class="sd">                index_intervals: The index intervals in the data array (Intervals object)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">sel_coordinate</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">intervals</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sel_coordinate</span> <span class="o">=</span> <span class="n">coordinate</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sel_coordinate</span> <span class="o">!=</span> <span class="n">coordinate</span><span class="p">):</span>
        <span class="k">raise</span> <span class="p">(</span><span class="s2">&quot;At present for spectral calculation the interval selection coordinate should be the same as the calculation coordinate.&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get_coordinate_object</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>
    
    <span class="k">try</span><span class="p">:</span>    
        <span class="n">calc_int</span><span class="p">,</span> <span class="n">calc_int_ind</span><span class="p">,</span> <span class="n">sel_int</span><span class="p">,</span> <span class="n">sel_int_ind</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">proc_interval_limits</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>
    <span class="n">intervals_low</span> <span class="o">=</span> <span class="n">sel_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">intervals_high</span> <span class="o">=</span> <span class="n">sel_int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    
<span class="c1"># This part is commented out as we assume identiacl coordinate for d and ref</span>

<span class="c1">#    d_intervals_low = sel_int[0]</span>
<span class="c1">#    d_intervals_high = sel_int[1]</span>

<span class="c1">#</span>
<span class="c1">#    if (ref is not None):</span>
<span class="c1">#        try:    </span>
<span class="c1">#            calc_int, calc_int_ind, sel_int, sel_int_ind = ref.proc_interval_limits(coordinate, intervals=intervals)</span>
<span class="c1">#        except Exception as e:</span>
<span class="c1">#            raise e</span>
<span class="c1">#        ref_intervals_low = sel_int[0]</span>
<span class="c1">#        ref_intervals_high = sel_int[1]</span>
<span class="c1">#        intervals_low = []</span>
<span class="c1">#        intervals_high = []</span>
<span class="c1">#        d_int_low_min = np.amin(d_intervals_low)</span>
<span class="c1">#        d_int_low_max = np.amax(d_intervals_low)</span>
<span class="c1">#        for i in range(len(ref_intervals_low)):</span>
<span class="c1">#            if ((ref_intervals_low[i] &gt;= d_int_low_min) and</span>
<span class="c1">#                  (ref_intervals_low &lt;= d_int_low_max)):</span>
<span class="c1">#                intervals_low.append(ref_intervals_low[i])</span>
<span class="c1">#                intervals_high.append(ref_intervals_high[i])</span>
<span class="c1">#        ref_coord = ref.get_coordinate_object(coordinate)</span>
<span class="c1">#        if ((math.fabs(ref_coord.start - coord.start) &gt; math.fabs(ref_coord.step[0] ) / 10)</span>
<span class="c1">#            or (math.fabs(ref_coord.step[0] - coord.step[0]) / math.fabs(ref_coord.step[0]) &gt; 1e-4) </span>
<span class="c1">#            ):</span>
<span class="c1">#            raise ValueError(&quot;The start and step of the calculating coordinates in the two data objects should be identical.&quot;)</span>
<span class="c1">#    else:</span>
<span class="c1">#        intervals_low = d_intervals_low </span>
<span class="c1">#        intervals_high = d_intervals_high</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals_low</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Ensuring that the intervals are in asceding order</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">intervals_low</span><span class="p">)</span>
        <span class="n">intervals_low</span> <span class="o">=</span> <span class="n">intervals_low</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
        <span class="n">intervals_high</span> <span class="o">=</span> <span class="n">intervals_high</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
        <span class="n">ind_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">intervals_high</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intervals_low</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_overlap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Intervals overlap, not suitable for calculation.&quot;</span><span class="p">)</span>
        <span class="n">intervals_length</span> <span class="o">=</span> <span class="n">intervals_high</span> <span class="o">-</span> <span class="n">intervals_low</span>
        <span class="c1"># Determining how many different intervals are available</span>
        <span class="n">int_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">intervals_low</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">int_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">ind_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">intervals_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_new</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">intervals_length</span> <span class="o">-</span> <span class="n">intervals_length</span><span class="p">[</span><span class="n">ind_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&lt;</span> <span class="n">margin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">int_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_lens</span><span class="p">,</span> <span class="n">intervals_length</span><span class="p">[</span><span class="n">ind_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">int_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_num</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
            <span class="n">intervals_length</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Sorting in reverse order according to interval length</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">int_lens</span><span class="p">)</span>
        <span class="n">int_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">int_num</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">])</span>
        <span class="n">int_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">int_lens</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">])</span>
        <span class="c1"># Dropping too small intervals</span>
        <span class="n">ind_small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">int_lens</span> <span class="o">&lt;</span> <span class="n">int_lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_small</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">int_lens</span> <span class="o">=</span> <span class="n">int_lens</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ind_small</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">int_num</span> <span class="o">=</span> <span class="n">int_num</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ind_small</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># Trying to use the shortest interval as processing length</span>
        <span class="n">proc_len</span> <span class="o">=</span> <span class="n">int_lens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">int_lens</span> <span class="o">&gt;=</span> <span class="n">proc_len</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">proc_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">int_num</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">proc_n</span> <span class="o">&lt;</span> <span class="n">interval_n</span><span class="p">):</span>
            <span class="c1"># If this is not successful splitting the intervals smaller and smaller</span>
            <span class="n">proc_len_start</span> <span class="o">=</span> <span class="n">proc_len</span>
            <span class="k">for</span> <span class="n">n_split</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">interval_n</span><span class="p">):</span>
                <span class="n">proc_len</span> <span class="o">=</span> <span class="n">proc_len_start</span> <span class="o">/</span> <span class="n">n_split</span>
                <span class="n">proc_n</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">int_lens</span><span class="p">)):</span>
                    <span class="n">proc_n</span> <span class="o">+=</span> <span class="p">(</span><span class="n">int_lens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">//</span> <span class="n">proc_len</span><span class="p">)</span> <span class="o">*</span> <span class="n">int_num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">proc_n</span> <span class="o">&gt;=</span> <span class="n">interval_n</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">interval_n</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; processing intervals.&quot;</span><span class="p">)</span>

        <span class="n">proc_interval_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">intervals_low</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">proc_interval_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">intervals_high</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals_low</span><span class="p">)):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">intervals_low</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">st</span> <span class="o">+</span> <span class="n">proc_len</span> <span class="o">&lt;=</span> <span class="n">intervals_high</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">margin</span><span class="p">):</span>
                <span class="n">proc_interval_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proc_interval_start</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span>
                <span class="n">proc_interval_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proc_interval_end</span><span class="p">,</span> <span class="n">st</span> <span class="o">+</span> <span class="n">proc_len</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">+=</span> <span class="n">proc_len</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">proc_interval_start</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">interval_n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal error in finding processing intervals.&quot;</span><span class="p">)</span>
        <span class="n">proc_interval_len</span> <span class="o">=</span> <span class="n">proc_len</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">proc_interval_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervals_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">intervals_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">interval_n</span>
        <span class="n">proc_interval_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">interval_n</span><span class="p">)</span> <span class="o">*</span> <span class="n">proc_interval_len</span> <span class="o">+</span> <span class="n">intervals_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">proc_interval_end</span> <span class="o">=</span> <span class="n">proc_interval_start</span> <span class="o">+</span> <span class="n">proc_interval_len</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">proc_interval_index_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">proc_interval_start</span> <span class="o">-</span> <span class="n">coord</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">proc_interval_index_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">proc_interval_len</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">proc_interval_index_end</span> <span class="o">=</span> <span class="n">proc_interval_index_start</span> <span class="o">+</span> <span class="n">proc_interval_index_len</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#npoint = d.shape[coord.dimension_list[0]]                              #UNUSED VARIABLE</span>
        <span class="n">proc_interval_index_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">proc_interval_len</span> <span class="o">/</span> <span class="n">step</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">proc_interval_index_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">proc_interval_end</span> <span class="o">-</span> <span class="n">coord</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">proc_interval_index_end</span> <span class="o">=</span> <span class="n">proc_interval_index_start</span> <span class="o">+</span> <span class="n">proc_interval_index_len</span>
    <span class="k">return</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Intervals</span><span class="p">(</span><span class="n">proc_interval_start</span><span class="p">,</span> <span class="n">proc_interval_end</span><span class="p">),</span>  \
           <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Intervals</span><span class="p">(</span><span class="n">proc_interval_index_start</span><span class="p">,</span> <span class="n">proc_interval_index_end</span><span class="p">),</span>

<div class="viewcode-block" id="trend_removal_func"><a class="viewcode-back" href="../../spectral_analysis.html#flap.spectral_analysis.trend_removal_func">[docs]</a><span class="k">def</span> <span class="nf">trend_removal_func</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_trend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_poly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function makes the _trend_removal internal function public</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_trend_removal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">return_trend</span><span class="o">=</span><span class="n">return_trend</span><span class="p">,</span> <span class="n">return_poly</span><span class="o">=</span><span class="n">return_poly</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_trend_removal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_trend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_poly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes the trend from the data. Operates on one axis between two indices of the data array.</span>
<span class="sd">    INPUT:</span>
<span class="sd">        d: Data array (Numpy array)</span>
<span class="sd">        ax: The axis along which to operate (0...)</span>
<span class="sd">        trend: Trend removal description. A list, string or None.</span>
<span class="sd">                None: Don&#39;t remove trend.</span>
<span class="sd">                Strings:</span>
<span class="sd">                    &#39;Mean&#39;: subtract mean</span>
<span class="sd">                Lists:</span>
<span class="sd">                    [&#39;Poly&#39;, n]: Fit an n order polynomial to the data and subtract.</span>
<span class="sd">        x: X axis. If not used equidistant will be assumed.</span>
<span class="sd">        return_trend: If True the trend data is returned</span>
<span class="sd">        return_poly: Return polynomial coefficients for poly trend removal. The coefficients will</span>
<span class="sd">                     be in axis ax.</span>
<span class="sd">    RETURN value:</span>
<span class="sd">        If return_trend == True the trend data is returned</span>
<span class="sd">        If (return_poly == True) and polyfit then return polynomial parameters</span>
<span class="sd">        Otherwise return None</span>
<span class="sd">        The input array is modified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">trend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trend</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Poly&#39;</span><span class="p">)):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">return_poly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polynomial trend fit parameters can be returned only for polynomial trend removal.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;Mean&#39;</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown trend removal method: &quot;</span><span class="o">+</span><span class="n">trend</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trend</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Poly&#39;</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">trend</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad order in polynomial trend removal.&quot;</span><span class="p">)</span>
            <span class="c1"># This is a simple solution but not very effective.</span>
            <span class="c1"># Flattens all dimensions except x and handles all functions one-by-one</span>
            <span class="c1"># Finally rearranges the data back to the original shape</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">_x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;u&#39;</span><span class="p">)):</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ax</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">return_trend</span><span class="p">):</span>
                        <span class="n">trend_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                    <span class="n">xx</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_x</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">order</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                        <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">xx</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">tr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">return_trend</span><span class="p">):</span>
                        <span class="n">trend_data</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
                   <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">orig_shape</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                   <span class="k">if</span> <span class="p">(</span><span class="n">return_trend</span><span class="p">):</span>
                       <span class="n">trend_data</span> <span class="o">=</span> <span class="n">trend_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">orig_shape</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                   <span class="k">if</span> <span class="p">(</span><span class="n">return_poly</span><span class="p">):</span>
                       <span class="n">p_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">orig_shape</span><span class="p">)</span>
                       <span class="n">p_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                       <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p_shape</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ax</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">return_trend</span><span class="p">):</span>
                        <span class="n">trend_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">trend_data</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">return_poly</span><span class="p">):</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">return_trend</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">trend_data</span>
                <span class="k">elif</span><span class="p">(</span><span class="n">return_poly</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">p</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">order</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">_x</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown trend removal method.&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_apsd</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auto power Spectral Density caclculation for the data object d.</span>
<span class="sd">        Returns a data object with the coordinate replaced by frequency or wavenumber.</span>
<span class="sd">        The power spectrum is calculated in multiple intervals (described by slicing)</span>
<span class="sd">        and the mean and variance will be returned.</span>

<span class="sd">        INPUT:</span>
<span class="sd">            d: A flap.DataObject.</span>
<span class="sd">            coordinate: The name of the coordinate (string) along which to calculate APSD.</span>
<span class="sd">                        This coordinate should change only along one data dimension and should be equidistant.</span>
<span class="sd">                        This and all other cordinates changing along the data dimension of</span>
<span class="sd">                        this coordinate will be removed. A new coordinate with name</span>
<span class="sd">                        Frequency/Wavenumber will be added. The unit will be</span>
<span class="sd">                        derived from the unit of the coordinate (e.g., Hz cm-1, m-1)</span>
<span class="sd">            intervals: Information of processing intervals.</span>
<span class="sd">                       If dictionary with a single key: {selection coordinate: description})</span>
<span class="sd">                           Key is a coordinate name which can be different from the calculation</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                           Description can be flap.Intervals, flap.DataObject or</span>
<span class="sd">                           a list of two numbers. If it is a data object with data name identical to</span>
<span class="sd">                           the coordinate the error ranges of the data object will be used for</span>
<span class="sd">                           interval. If the data name is not the same as coordinate a coordinate with the</span>
<span class="sd">                           same name will be searched for in the data object and the value_ranges</span>
<span class="sd">                           will be used fromm it to set the intervals.</span>
<span class="sd">                       If not a dictionary and not None it is interpreted as the interval</span>
<span class="sd">                           description, the selection coordinate is taken the same as</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                       If None, the whole data interval will be used as a single interval.</span>
<span class="sd">            options: Dictionary. (Keys can be abbreviated)</span>
<span class="sd">                &#39;Wavenumber&#39; : True/False. Will use 2*Pi*f for the output coordinate scale, this is useful for</span>
<span class="sd">                               wavenumber calculation.</span>
<span class="sd">                &#39;Resolution&#39;: Output resolution in the unit of the output coordinate.</span>
<span class="sd">                &#39;Range&#39;: Output range in the unit of the output coordinate.</span>
<span class="sd">                &#39;Logarithmic&#39;: True/False. If True will create logarithmic frequency binning.</span>
<span class="sd">                &#39;Interval_n&#39;: Minimum number of intervals to use for the processing. These are identical</span>
<span class="sd">                              length intervals inserted into the input interval list. Default is 8.</span>
<span class="sd">                &#39;Error calculation&#39; : True/False. Calculate or not error. Omitting error calculation</span>
<span class="sd">                                      increases speed. If Interval_n is 1 no error calculation is done.</span>
<span class="sd">                &#39;Trend removal&#39;: Trend removal description (see also _trend_removal()). A list, string or None.</span>
<span class="sd">                             None: Don&#39;t remove trend.</span>
<span class="sd">                             Strings:</span>
<span class="sd">                               &#39;Mean&#39;: subtract mean</span>
<span class="sd">                             Lists:</span>
<span class="sd">                               [&#39;Poly&#39;, n]: Fit an n order polynomial to the data and subtract.</span>
<span class="sd">                            Trend removal will be applied to each interval separately.</span>
<span class="sd">                 &#39;Hanning&#39;: True/False Use a Hanning window.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot do spectral analysis without data.&quot;</span><span class="p">)</span>
    <span class="n">default_options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Wavenumber&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;Resolution&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s1">&#39;Range&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s1">&#39;Logarithmic&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;Interval_n&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                       <span class="s1">&#39;Trend removal&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Poly&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                       <span class="s1">&#39;Error calculation&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="s1">&#39;Hanning&#39;</span> <span class="p">:</span> <span class="kc">True</span>
                       <span class="p">}</span>
    <span class="n">_options</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">merge_options</span><span class="p">(</span><span class="n">default_options</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">data_source</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;PS&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">c_names</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">coordinate_names</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
            <span class="n">_coordinate</span> <span class="o">=</span> <span class="s1">&#39;Time&#39;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No coordinate is given for spectrum calculation and no Time coordinate found.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_coordinate</span> <span class="o">=</span> <span class="n">coordinate</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Trend removal&#39;</span><span class="p">]</span>
    <span class="n">wavenumber</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Wavenumber&#39;</span><span class="p">]</span>
    <span class="n">interval_n</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Interval_n&#39;</span><span class="p">]</span>
    <span class="n">log_scale</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Logarithmic&#39;</span><span class="p">]</span>
    <span class="n">hanning</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Hanning&#39;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coord_obj</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get_coordinate_object</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum calculation is possible only along coordinates changing along one dimension.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">coord_obj</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">equidistant</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum calculation is possible only along equidistant coordinates.&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">intervals</span><span class="p">,</span> <span class="n">index_intervals</span> <span class="o">=</span> <span class="n">_spectral_calc_interval_selection</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">_coordinate</span><span class="p">,</span><span class="n">intervals</span><span class="p">,</span><span class="n">interval_n</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>
    <span class="n">interval_n</span><span class="p">,</span> <span class="n">start_ind</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_number</span><span class="p">()</span>
    <span class="n">calc_error</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Error calculation&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interval_n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">calc_error</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">int_low</span><span class="p">,</span> <span class="n">int_high</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_limits</span><span class="p">()</span>
    <span class="n">res_nat</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">range_nat</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">index_int_low</span><span class="p">,</span> <span class="n">index_int_high</span> <span class="o">=</span> <span class="n">index_intervals</span><span class="o">.</span><span class="n">interval_limits</span><span class="p">()</span>
    <span class="n">interval_sample_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="c1"># Determining the output array shape.</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Determining two pairs of index tuples for copying the data after PS calculation</span>
    <span class="c1"># of one time interval. For complex data we need to copy in two steps</span>
    <span class="n">proc_dim</span> <span class="o">=</span> <span class="n">coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="p">):</span>
        <span class="c1"># For complex data negative frequencies are also valuable</span>
        <span class="c1"># n_apsd is the number of valuable points in the spectrum after rearrangement but before</span>
        <span class="c1"># and range and resolution transformation</span>
        <span class="n">n_apsd</span> <span class="o">=</span> <span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># These will be tuples used in reorganizing the raw FFT spectra into continuous</span>
        <span class="c1"># frequency scale. We need this as for complex data the negative frequencies are</span>
        <span class="c1"># in the second half of the array</span>
        <span class="n">ind_in1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">ind_in2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
        <span class="n">ind_out1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
        <span class="n">ind_out2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
        <span class="n">ind_in1</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">ind_out1</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">n_apsd</span><span class="p">)</span>
        <span class="c1"># zero_ind is the index where the 0 frequency will be after rearranging the spectrum</span>
        <span class="n">zero_ind</span> <span class="o">=</span> <span class="n">n_apsd</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ind_in2</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">n_apsd</span><span class="p">)</span>
        <span class="n">ind_out2</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_apsd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ind_in1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">ind_in1</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_apsd</span><span class="p">)</span>
        <span class="n">zero_ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ind_out1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ind_in2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ind_out2</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="c1"># Calculating the binning boxes from the resolution and range and related indices   </span>
    <span class="n">ind_bin</span><span class="p">,</span> <span class="n">ind_slice</span><span class="p">,</span> <span class="n">out_data_num</span><span class="p">,</span> <span class="n">ind_nonzero</span><span class="p">,</span> <span class="n">index_nonzero</span><span class="p">,</span> <span class="n">ind_zero</span><span class="p">,</span> <span class="n">nf_out</span><span class="p">,</span> <span class="n">f_cent</span><span class="p">,</span> \
    <span class="n">fcent_index_range</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">_spectrum_binning_indices</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">,</span>
                                                       <span class="n">n_apsd</span><span class="p">,</span> 
                                                       <span class="n">_options</span><span class="p">,</span> 
                                                       <span class="n">zero_ind</span><span class="p">,</span> 
                                                       <span class="n">res_nat</span><span class="p">,</span>
                                                       <span class="n">range_nat</span><span class="p">,</span>
                                                       <span class="n">log_scale</span><span class="p">,</span> 
                                                       <span class="n">out_shape</span><span class="p">,</span> 
                                                       <span class="n">proc_dim</span><span class="p">)</span>
                
    <span class="n">out_shape</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nf_out</span>
    <span class="c1"># These arrays will collect the data and the square of the data to enable error calculation</span>
    <span class="n">out_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">calc_error</span><span class="p">):</span>
        <span class="n">out_data_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># This is a tuple to index into the original data array to get data for processing</span>
    <span class="n">ind_proc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="c1"># Number of processing intervals</span>
    <span class="n">n_proc_int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_low</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hanning</span><span class="p">):</span>
        <span class="n">hanning_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="n">hanning_window</span> <span class="o">/=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">han_sh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">han_sh</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">size</span>
            <span class="n">hanning_window</span> <span class="o">=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">han_sh</span><span class="p">)</span>
    <span class="c1"># We need to determine a shape to which the out_data_num array will be broadcasted to </span>
    <span class="c1"># allow dividing all spectra. bs is this shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">out_data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">bs</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_nonzero</span><span class="p">)</span>
        <span class="n">bs</span><span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">out_data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">bs</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i_int</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
        <span class="c1"># Setting the index range of the actual interval</span>
        <span class="n">ind_proc</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_int_low</span><span class="p">[</span><span class="n">i_int</span><span class="p">],</span> <span class="n">index_int_high</span><span class="p">[</span><span class="n">i_int</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Getting the data for processing, this might be multi-dim</span>
        <span class="n">data_proc</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_proc</span><span class="p">)])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">trend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_trend_removal</span><span class="p">(</span><span class="n">data_proc</span><span class="p">,</span><span class="n">proc_dim</span><span class="p">,</span><span class="n">trend</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hanning</span><span class="p">):</span>
           <span class="n">data_proc</span> <span class="o">*=</span> <span class="n">hanning_window</span>
        <span class="c1"># Calculating APS on natural resolution, full frequency scale</span>
        <span class="n">dfft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">data_proc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">proc_dim</span><span class="p">)</span>
        <span class="n">dps</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfft</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">dfft</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># Rearranging the negative frequencies</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_in2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">dps1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dps</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dps</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">dps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)]</span>
            <span class="n">dps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2</span><span class="p">)]</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="n">dps1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)]</span>
        <span class="c1"># Cutting the range</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">ind_slice</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice</span><span class="p">)]</span>
        <span class="c1"># Binning the spectrum and summing up the time intervals</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_bin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">out_data_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">out_data_interval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin</span><span class="p">),</span> <span class="n">dps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_data_interval</span> <span class="o">=</span> <span class="n">dps</span>
        <span class="c1"># Dividing by the number of points in each bin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">out_data_interval</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_nonzero</span><span class="p">)]</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="p">[</span><span class="n">index_nonzero</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_data_interval</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="n">out_data_interval</span> <span class="o">/=</span> <span class="n">interval_sample_n</span>
        <span class="n">out_data</span> <span class="o">+=</span> <span class="n">out_data_interval</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">calc_error</span><span class="p">):</span>
            <span class="n">out_data_square</span> <span class="o">+=</span> <span class="n">out_data_interval</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">out_data</span> <span class="o">/=</span> <span class="n">n_proc_int</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">calc_error</span><span class="p">):</span>
        <span class="n">out_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">out_data_square</span> <span class="o">/</span> <span class="n">n_proc_int</span> <span class="o">-</span> <span class="n">out_data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                                  <span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_err</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># If there are frequency bins without data setting them to np.NaN</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">out_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_zero</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
    <span class="c1"># We create the new data object with this trick as data_object.py cannot be imported</span>
    <span class="n">d_out</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)(</span><span class="n">data_array</span><span class="o">=</span><span class="n">out_data</span><span class="p">,</span>
                    <span class="n">error</span><span class="o">=</span><span class="n">out_err</span><span class="p">,</span>
                    <span class="n">coordinates</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">exp_id</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">exp_id</span><span class="p">,</span>
                    <span class="n">data_unit</span><span class="o">=</span><span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;Spectral density&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wavenumber</span><span class="p">):</span>
        <span class="n">out_name</span> <span class="o">=</span> <span class="s1">&#39;Wavenumber&#39;</span>
        <span class="n">out_unit</span> <span class="o">=</span> <span class="s1">&#39;1/&#39;</span><span class="o">+</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">res</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1">#fcent *= 2* math.pi                                                        #UNUSED VARIABLE</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_name</span> <span class="o">=</span> <span class="s1">&#39;Frequency&#39;</span>
        <span class="n">out_unit</span> <span class="o">=</span> <span class="s1">&#39;Hz&#39;</span>

    <span class="c1"># Finding all coordinates which have common dimension with the converted one.</span>
    <span class="c1"># These will be deleted.</span>
    <span class="n">del_coord_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d_out</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">proc_dim</span><span class="p">)</span>
            <span class="n">del_coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">del_coord_list</span><span class="p">:</span>
        <span class="n">d_out</span><span class="o">.</span><span class="n">del_coordinate</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">log_scale</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Coordinate</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">out_name</span><span class="p">,</span>
                                       <span class="n">unit</span> <span class="o">=</span> <span class="n">out_unit</span><span class="p">,</span>
                                       <span class="n">mode</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">CoordinateMode</span><span class="p">(</span><span class="n">equidistant</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                       <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">f_cent</span><span class="o">.</span><span class="n">size</span><span class="p">],</span>
                                       <span class="n">values</span> <span class="o">=</span> <span class="n">f_cent</span><span class="p">,</span>
                                       <span class="n">dimension_list</span><span class="o">=</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Coordinate</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">out_name</span><span class="p">,</span>
                                       <span class="n">unit</span> <span class="o">=</span> <span class="n">out_unit</span><span class="p">,</span>
                                       <span class="n">mode</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">CoordinateMode</span><span class="p">(</span><span class="n">equidistant</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                       <span class="n">shape</span> <span class="o">=</span> <span class="p">[],</span>
                                       <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">zero_ind</span><span class="p">)</span> <span class="o">*</span> <span class="n">res</span><span class="p">,</span>
                                       <span class="n">step</span> <span class="o">=</span> <span class="n">res</span><span class="p">,</span>
                                       <span class="n">dimension_list</span><span class="o">=</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">])</span>
    <span class="n">d_out</span><span class="o">.</span><span class="n">add_coordinate_object</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d_out</span>

<span class="k">def</span> <span class="nf">_spectrum_binning_indices</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">,</span> <span class="n">n_apsd</span><span class="p">,</span> <span class="n">_options</span><span class="p">,</span> <span class="n">zero_ind</span><span class="p">,</span> <span class="n">res_nat</span><span class="p">,</span> <span class="n">range_nat</span><span class="p">,</span> <span class="n">log_scale</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">proc_dim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Helper routine for apsd and cpsd for calculating numbers and indices</span>
<span class="sd">        for processing the spectra.</span>
<span class="sd">        Returns: ind_bin, ind_slice, out_data_num, ind_nonzero, index_nonzero, ind_zero, nf_out, </span>
<span class="sd">        f_cent, fcent_index_range, res</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculating the binning boxes from the resolution and range</span>
    <span class="n">fscale_nat</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_apsd</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">zero_ind</span><span class="p">)</span> <span class="o">*</span> <span class="n">res_nat</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">log_scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Range&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">rang</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Range&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">rang</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rang</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid spectrum range setting.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span>
                <span class="n">rang</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="p">,</span> <span class="n">range_nat</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res_nat</span>
                <span class="n">rang</span> <span class="o">=</span> <span class="p">[</span><span class="n">res_nat</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="n">range_nat</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">rang</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Illegal frequency range.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Illegal frequency range for logarithmic frequency resolution.&quot;</span><span class="p">)</span>
        <span class="c1"># Setting the lower and upper limit of the first box so as f_high-f_low=res and</span>
        <span class="c1"># (log10(f_low)+log10(f_high))/2 = log10(range[0])</span>
        <span class="n">f_low</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">res</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">res</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span> <span class="mi">2</span>
        <span class="n">f_high</span> <span class="o">=</span> <span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">f_low</span>
        <span class="c1"># Setting up a box list which is linear on the log scale</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_high</span><span class="o">/</span><span class="n">f_low</span><span class="p">)</span>
        <span class="n">nf_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">rang</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_low</span><span class="p">))</span> <span class="o">//</span> <span class="n">delta</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">f_box</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">f_low</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf_out</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>
<span class="c1">#        if (f_box[-1] &gt; range_nat[1]):</span>
<span class="c1">#            f_box[-1] = range_nat[1]</span>
        <span class="c1"># Box index for the original spectrum points</span>
        <span class="n">apsd_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">fscale_nat</span><span class="p">,</span> <span class="n">f_box</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ind_out_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">apsd_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ind_out_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">apsd_index</span> <span class="o">&gt;=</span> <span class="n">f_box</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">ind_out_low</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind_out_high</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind_out_low</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">slice_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_start</span> <span class="o">=</span> <span class="n">ind_out_low</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind_out_high</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">slice_end</span> <span class="o">=</span> <span class="n">fscale_nat</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_end</span> <span class="o">=</span> <span class="n">ind_out_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">apsd_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slice_start</span><span class="p">,</span> <span class="n">slice_end</span><span class="p">)</span>
            <span class="n">ind_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
            <span class="n">ind_slice</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">apsd_slice</span>
            <span class="n">apsd_index</span> <span class="o">=</span> <span class="n">apsd_index</span><span class="p">[</span><span class="n">apsd_slice</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apsd_slice</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ind_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">f_cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f_box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f_box</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">nf_out</span> <span class="o">=</span> <span class="n">f_cent</span><span class="o">.</span><span class="n">size</span>
        <span class="n">out_data_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nf_out</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">out_data_num</span><span class="p">,</span> <span class="n">apsd_index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">index_nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">out_data_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index_nonzero</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">out_data_num</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">ind_nonzero</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ind_zero</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_nonzero</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
            <span class="n">ind_nonzero</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_nonzero</span>
            <span class="n">index_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">out_data_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind_zero</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
            <span class="n">ind_zero</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_zero</span>
        <span class="n">ind_bin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
        <span class="n">ind_bin</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">apsd_index</span>
        <span class="n">fcent_index_range</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Linear scale</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">wavenumber</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="n">range_nat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Requested resolution is too coarse.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res_nat</span>
        <span class="n">res_bin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">res</span> <span class="o">/</span> <span class="n">res_nat</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res_bin</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">res_bin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res_nat</span> <span class="o">*</span> <span class="n">res_bin</span>
        <span class="c1"># Determining the number of bins</span>

        <span class="n">nf_out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span> <span class="o">/</span> <span class="n">res_bin</span><span class="p">)</span>

        <span class="c1"># The index range in the apsd array where the central frequencies are available</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res_bin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">fcent_index_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_apsd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">nf_out</span> <span class="o">=</span> <span class="n">n_apsd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fcent_index_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">zero_ind</span> <span class="o">%</span> <span class="n">res_bin</span><span class="p">,</span>
                                 <span class="p">(</span><span class="n">n_apsd</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">zero_ind</span> <span class="o">%</span> <span class="n">res_bin</span><span class="p">))</span> <span class="o">//</span> <span class="n">res_bin</span> <span class="o">*</span> <span class="n">res_bin</span>
                                   <span class="o">+</span> <span class="n">zero_ind</span> <span class="o">%</span> <span class="n">res_bin</span><span class="p">]</span>
            <span class="n">nf_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">//</span> <span class="n">res_bin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Range&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">rang</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Range&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">rang</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rang</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid spectrum range setting.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">rang</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Illegal frequency range.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">res_nat</span> <span class="o">+</span> <span class="n">zero_ind</span><span class="p">):</span>
                <span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">rang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">res</span><span class="p">))</span> <span class="o">*</span> <span class="n">res_bin</span> <span class="o">+</span> <span class="n">zero_ind</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">res_nat</span> <span class="o">+</span> <span class="n">zero_ind</span><span class="p">):</span>
                <span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">rang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">res</span><span class="p">))</span> <span class="o">*</span> <span class="n">res_bin</span> <span class="o">+</span> <span class="n">zero_ind</span>
        <span class="n">nf_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">//</span> <span class="n">res_bin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nf_out</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too coarse spectrum resolution.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_apsd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> \
             <span class="ow">or</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_apsd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum axis range is outside of natural ranges.&quot;</span><span class="p">)</span>
        <span class="c1"># This slice will cut the necessary part from the raw APSD sepctrum</span>
        <span class="n">apsd_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_bin</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                          <span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">res_bin</span> <span class="o">-</span> <span class="n">res_bin</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># A full box start is this number of apsd spectrum pints before apsd_slice.start</span>
        <span class="n">start_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">apsd_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">start_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="n">apsd_slice</span><span class="o">.</span><span class="n">start</span>
            <span class="n">apsd_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">apsd_slice</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">apsd_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">&gt;</span> <span class="n">n_apsd</span><span class="p">):</span>
            <span class="n">apsd_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">apsd_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">n_apsd</span><span class="p">)</span>
        <span class="c1"># This index array will contain the box index for each APSD spectral point remaining after</span>
        <span class="c1"># the above slice</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res_bin</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">apsd_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">apsd_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">apsd_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                          <span class="o">+</span> <span class="n">start_shift</span><span class="p">)</span> <span class="o">//</span> <span class="n">res_bin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apsd_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">apsd_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
            <span class="n">ind_slice</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">apsd_slice</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">apsd_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_bin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
            <span class="n">ind_bin</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">apsd_index</span>
            <span class="n">out_data_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nf_out</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">out_data_num</span><span class="p">,</span> <span class="n">apsd_index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_bin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">out_data_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nf_out</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ind_nonzero</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">index_nonzero</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ind_zero</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">f_cent</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">ind_bin</span><span class="p">,</span> <span class="n">ind_slice</span><span class="p">,</span> <span class="n">out_data_num</span><span class="p">,</span> <span class="n">ind_nonzero</span><span class="p">,</span> <span class="n">index_nonzero</span><span class="p">,</span> <span class="n">ind_zero</span><span class="p">,</span> <span class="n">nf_out</span><span class="p">,</span> \
           <span class="n">f_cent</span><span class="p">,</span><span class="n">fcent_index_range</span><span class="p">,</span> <span class="n">res</span>
    
<span class="k">def</span> <span class="nf">_cpsd</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Complex Cross Power Spectrum calculation for the data object d taking d_ref as reference.</span>
<span class="sd">        If ref is not set d is used as reference, that is all spectra are calculated within d.</span>
<span class="sd">        Calculates all spectra between all signals in ref and d, but not inside d and ref.</span>
<span class="sd">        d and ref both should have the same equidistant coordinate with equal sampling points.</span>
<span class="sd">        Returns a data object with dimension number d.dim+ref.dim-1. The coordinate is replaced </span>
<span class="sd">        by frequency or wavenumber.</span>
<span class="sd">        The spectrum is calculated in multiple intervals (described by slicing)</span>
<span class="sd">        and the mean and variance will be returned.</span>

<span class="sd">        INPUT:</span>
<span class="sd">            d: A flap.DataObject.</span>
<span class="sd">            ref: Another flap.DataObject</span>
<span class="sd">            coordinate: The name of the coordinate (string) along which to calculate CPSD.</span>
<span class="sd">                        This coordinate should change only along one data dimension and should be equidistant.</span>
<span class="sd">                        This and all other cordinates changing along the data dimension of</span>
<span class="sd">                        this coordinate will be removed. A new coordinate with name</span>
<span class="sd">                        Frequency/Wavenumber will be added. The unit will be</span>
<span class="sd">                        derived from the unit of the coordinate (e.g., Hz cm-1, m-1)</span>
<span class="sd">            intervals: Information of processing intervals.</span>
<span class="sd">                       If dictionary with a single key: {selection coordinate: description})</span>
<span class="sd">                           Key is a coordinate name which can be different from the calculation</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                           Description can be flap.Intervals, flap.DataObject or</span>
<span class="sd">                           a list of two numbers. If it is a data object with data name identical to</span>
<span class="sd">                           the coordinate the error ranges of the data object will be used for</span>
<span class="sd">                           interval. If the data name is not the same as coordinate a coordinate with the</span>
<span class="sd">                           same name will be searched for in the data object and the value_ranges</span>
<span class="sd">                           will be used fromm it to set the intervals.</span>
<span class="sd">                       If not a dictionary and not None it is interpreted as the interval</span>
<span class="sd">                           description, the selection coordinate is taken the same as</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                       If None, the whole data interval will be used as a single interval.</span>
<span class="sd">            options: Dictionary. (Keys can be abbreviated)</span>
<span class="sd">                &#39;Wavenumber&#39; : True/False. Will use 2*Pi*f for the output coordinate scale, this is useful for</span>
<span class="sd">                               wavenumber calculation.</span>
<span class="sd">                &#39;Resolution&#39;: Output resolution in the unit of the output coordinate.</span>
<span class="sd">                &#39;Range&#39;: Output range in the unit of the output coordinate.</span>
<span class="sd">                &#39;Logarithmic&#39;: True/False. If True will create logarithmic frequency binning.</span>
<span class="sd">                &#39;Interval_n&#39;: Minimum number of intervals to use for the processing. These are identical</span>
<span class="sd">                              length intervals inserted into the input interval list. Default is 8.</span>
<span class="sd">                &#39;Error calculation&#39; : True/False. Calculate or not error. Omitting error calculation</span>
<span class="sd">                                      increases speed. If Interval_n is 1 no error calculation is done.</span>
<span class="sd">                &#39;Trend removal&#39;: Trend removal description (see also _trend_removal()). A list, string or None.</span>
<span class="sd">                             None: Don&#39;t remove trend.</span>
<span class="sd">                             Strings:</span>
<span class="sd">                               &#39;mean&#39;: subtract mean</span>
<span class="sd">                             Lists:</span>
<span class="sd">                               [&#39;Poly&#39;, n]: Fit an n order polynomial to the data and subtract.</span>
<span class="sd">                            Trend removal will be applied to each interval separately.</span>
<span class="sd">                &#39;Hanning&#39;: True/False Use a Hanning window.</span>
<span class="sd">                &#39;Error calculation&#39; : True/False. Calculate or not error. Omitting error calculation</span>
<span class="sd">                                      increases speed. If Interval_n is 1 no error calculation is done.</span>
<span class="sd">                &#39;Normalize&#39;: Normalize crosspower spectrum, that is return</span>
<span class="sd">        Return value:</span>
<span class="sd">            Three data objects:</span>
<span class="sd">            spectrum, phase, confidence</span>
<span class="sd">                spectrum: The complex power spectrum or coherency if options[&#39;Normalize&#39;] is True</span>
<span class="sd">                          The error will contain the condifence level.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot do spectral analysis without data.&quot;</span><span class="p">)</span>

    <span class="n">default_options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Wavenumber&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;Resolution&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s1">&#39;Range&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s1">&#39;Logarithmic&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;Interval_n&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                       <span class="s1">&#39;Trend removal&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Poly&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                       <span class="s1">&#39;Hanning&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="s1">&#39;Error calculation&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="s1">&#39;Normalize&#39;</span><span class="p">:</span> <span class="kc">False</span>
                       <span class="p">}</span>
    <span class="n">_options</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">merge_options</span><span class="p">(</span><span class="n">default_options</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">data_source</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;PS&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">c_names</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">coordinate_names</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
            <span class="n">_coordinate</span> <span class="o">=</span> <span class="s1">&#39;Time&#39;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No coordinate is given for spectrum calculation and no Time coordinate found.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_coordinate</span> <span class="o">=</span> <span class="n">coordinate</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Trend removal&#39;</span><span class="p">]</span>
    <span class="n">wavenumber</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Wavenumber&#39;</span><span class="p">]</span>
    <span class="n">interval_n</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Interval_n&#39;</span><span class="p">]</span>
    <span class="n">log_scale</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Logarithmic&#39;</span><span class="p">]</span>
    <span class="n">hanning</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Hanning&#39;</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Normalize&#39;</span><span class="p">]</span>
    <span class="n">error_calc</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Error calculation&#39;</span><span class="p">]</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coord_obj</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get_coordinate_object</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum calculation is possible only along coordinates changing in one dimension.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">coord_obj</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">equidistant</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum calculation is possible only along equidistant coordinates.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">_ref</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">ref_coord_obj</span> <span class="o">=</span> <span class="n">coord_obj</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">intervals</span><span class="p">,</span> <span class="n">index_intervals</span> <span class="o">=</span> <span class="n">_spectral_calc_interval_selection</span><span class="p">(</span><span class="n">d</span><span class="p">,</span>
                                                                           <span class="kc">None</span><span class="p">,</span> 
                                                                           <span class="n">_coordinate</span><span class="p">,</span>
                                                                           <span class="n">intervals</span><span class="p">,</span>
                                                                           <span class="n">interval_n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_ref</span> <span class="o">=</span> <span class="n">ref</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ref_coord_obj</span> <span class="o">=</span> <span class="n">_ref</span><span class="o">.</span><span class="n">get_coordinate_object</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum calculation is possible only along coordinates changing in one dimension (ref).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">equidistant</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum calculation is possible only along equidistant coordinates (ref).&quot;</span><span class="p">)</span>    
        <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_obj</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> \
            <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
               <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible coordinate step sizes.&quot;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">coord_obj</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                   <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible coordinate start values.&quot;</span> <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">intervals</span><span class="p">,</span> <span class="n">index_intervals</span> <span class="o">=</span> <span class="n">_spectral_calc_interval_selection</span><span class="p">(</span><span class="n">d</span><span class="p">,</span>
                                                                           <span class="n">_ref</span><span class="p">,</span> 
                                                                           <span class="n">_coordinate</span><span class="p">,</span>
                                                                           <span class="n">intervals</span><span class="p">,</span>
                                                                           <span class="n">interval_n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
                        
    <span class="n">interval_n</span><span class="p">,</span> <span class="n">start_ind</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_number</span><span class="p">()</span>

    <span class="n">int_low</span><span class="p">,</span> <span class="n">int_high</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_limits</span><span class="p">()</span>
    <span class="n">res_nat</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">range_nat</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">index_int_low</span><span class="p">,</span> <span class="n">index_int_high</span> <span class="o">=</span> <span class="n">index_intervals</span><span class="o">.</span><span class="n">interval_limits</span><span class="p">()</span>
    <span class="n">interval_sample_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># The processing dimensions in the two objects</span>
    <span class="n">proc_dim</span> <span class="o">=</span> <span class="n">coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">proc_dim_ref</span> <span class="o">=</span> <span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Determining the output array shape. First the d object dimensions will come, the</span>
    <span class="c1"># spectrum scale will be proc_dim. Then the ref dimensions will come with proc_dim_ref removed.</span>
    <span class="c1"># The size of the output array in the processig dimension will be entered later</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">out_shape_add</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">out_shape_add</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span>
    <span class="n">out_shape</span> <span class="o">+=</span> <span class="n">out_shape_add</span>
    <span class="n">proc_dim_out</span> <span class="o">=</span> <span class="n">proc_dim</span>
    
    <span class="c1"># Flag to show whether the APSDs should be calculated</span>
    <span class="n">aps_calc</span> <span class="o">=</span> <span class="n">error_calc</span> <span class="ow">or</span> <span class="n">norm</span>
    
    <span class="c1"># Determining two pairs of index tuples for copying the data after PS calculation</span>
    <span class="c1"># of one time interval. For complex data we need to copy in two steps</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">)):</span>
        <span class="c1"># For complex data negative frequencies are also valuable</span>
        <span class="c1"># n_apsd is the number of valuable points in the spectrum after rearrangement but before</span>
        <span class="c1"># and range and resolution transformation</span>
        <span class="n">n_apsd</span> <span class="o">=</span> <span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>                                   <span class="c1">#THIS WAS n_cpsd BEFORE, WOULD HAVE CAUSED AN ERROR</span>
        <span class="c1"># These will be tuples used in reorganizing the raw FFT spectra into continuous</span>
        <span class="c1"># frequency scale. We need this as for complex data the negative frequencies are</span>
        <span class="c1"># in the second half of the array</span>
        <span class="n">ind_in1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
        <span class="n">ind_in2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
        <span class="n">ind_out1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
        <span class="n">ind_out2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
        <span class="n">ind_in1</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">ind_out1</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">n_apsd</span><span class="p">)</span>
        <span class="c1"># zero_ind is the index where the 0 frequency will be after rearranging the spectrum</span>
        <span class="n">zero_ind</span> <span class="o">=</span> <span class="n">n_apsd</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ind_in2</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">n_apsd</span><span class="p">)</span>
        <span class="n">ind_out2</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
            <span class="n">ind_in1_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_in2_apsd</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_apsd</span><span class="p">)</span>
            <span class="n">ind_out1_apsd</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_apsd</span><span class="p">)</span>
            <span class="n">ind_out2_apsd</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_apsd</span><span class="p">)</span>
            <span class="n">ind_in1_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">ind_in2_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">n_apsd</span><span class="p">)</span>
            <span class="n">ind_out1_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">n_apsd</span><span class="p">)</span>
            <span class="n">ind_out2_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">ind_in1_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_in2_apsd_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_apsd_ref</span><span class="p">)</span>
            <span class="n">ind_out1_apsd_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_apsd_ref</span><span class="p">)</span>
            <span class="n">ind_out2_apsd_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_apsd_ref</span><span class="p">)</span>
            <span class="n">ind_in1_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">ind_in2_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">n_apsd</span><span class="p">)</span>
            <span class="n">ind_out1_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">n_apsd</span><span class="p">)</span>
            <span class="n">ind_out2_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_apsd</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_apsd</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_apsd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ind_in1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
        <span class="n">ind_in1</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_apsd</span><span class="p">)</span>
        <span class="n">zero_ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ind_out1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ind_in2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ind_out2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
            <span class="n">ind_in1_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_in1_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_apsd</span><span class="p">)</span>
            <span class="n">ind_in1_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_in1_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_apsd</span><span class="p">)</span>
 
    <span class="n">ind_bin</span><span class="p">,</span> <span class="n">ind_slice</span><span class="p">,</span> <span class="n">out_data_num</span><span class="p">,</span> <span class="n">ind_nonzero</span><span class="p">,</span> <span class="n">index_nonzero</span><span class="p">,</span> <span class="n">ind_zero</span><span class="p">,</span> <span class="n">nf_out</span><span class="p">,</span> <span class="n">f_cent</span><span class="p">,</span> \
    <span class="n">fcent_index_range</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">_spectrum_binning_indices</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">,</span> <span class="n">n_apsd</span><span class="p">,</span> 
                                            <span class="n">_options</span><span class="p">,</span> 
                                            <span class="n">zero_ind</span><span class="p">,</span> 
                                            <span class="n">res_nat</span><span class="p">,</span>
                                            <span class="n">range_nat</span><span class="p">,</span>
                                            <span class="n">log_scale</span><span class="p">,</span> 
                                            <span class="n">out_shape</span><span class="p">,</span> 
                                            <span class="n">proc_dim_out</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_slice_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_slice_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_slice</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>
            <span class="n">ind_slice_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_slice_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_slice</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_slice_apsd</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ind_slice_apsd_ref</span> <span class="o">=</span> <span class="kc">None</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_bin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_bin_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_bin_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_bin</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>
            <span class="n">ind_bin_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_bin_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_bin</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_bin_apsd</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ind_bin_apsd_ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_nonzero_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_nonzero_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_nonzero</span>
            <span class="n">ind_nonzero_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">ind_nonzero_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_nonzero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_nonzero_apsd</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ind_nonzero_apsd_ref</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="n">out_shape</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">nf_out</span>

    <span class="c1"># This will collect the output data</span>
    <span class="n">out_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># These will collect the autospectra</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
        <span class="n">apsd_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">apsd_shape</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nf_out</span>
        <span class="n">apsd_ref_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">apsd_ref_shape</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">nf_out</span>
        <span class="n">apsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">apsd_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">apsd_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">apsd_ref_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># This is a tuple to index into the original data arrays to get data for processing</span>
    <span class="n">ind_proc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">ind_proc_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="c1"># Number of processing intervals</span>
    <span class="n">n_proc_int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_low</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hanning</span><span class="p">):</span>
        <span class="n">hanning_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="n">hanning_window</span> <span class="o">/=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">han_sh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">han_sh</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">size</span>
            <span class="n">hanning_window</span> <span class="o">=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">han_sh</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">han_sh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">han_sh</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">size</span>
            <span class="n">hanning_window_ref</span> <span class="o">=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">han_sh</span><span class="p">)</span>

    <span class="c1"># We need to determine a shape to which the out_data_num array will be broadcasted to </span>
    <span class="c1"># allow dividing all spectra. bs is this shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">out_data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">bs</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_nonzero</span><span class="p">)</span>
        <span class="n">bs</span><span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
            <span class="n">bs_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">bs_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_nonzero</span><span class="p">)</span>
            <span class="n">bs_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">bs_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_nonzero</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">out_data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">bs</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
            <span class="n">bs_apsd</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">bs_apsd</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>
            <span class="n">bs_apsd_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">bs_apsd_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">proc_dim_out</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i_int</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
        <span class="c1"># Setting the index range of the actual interval</span>
        <span class="n">ind_proc</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_int_low</span><span class="p">[</span><span class="n">i_int</span><span class="p">],</span> <span class="n">index_int_high</span><span class="p">[</span><span class="n">i_int</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ind_proc_ref</span><span class="p">[</span><span class="n">proc_dim_ref</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_int_low</span><span class="p">[</span><span class="n">i_int</span><span class="p">],</span> <span class="n">index_int_high</span><span class="p">[</span><span class="n">i_int</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Getting the data for processing, this might be multi-dim</span>
        <span class="n">data_proc</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_proc</span><span class="p">)])</span>
        <span class="n">data_proc_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_proc_ref</span><span class="p">)])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">trend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_trend_removal</span><span class="p">(</span><span class="n">data_proc</span><span class="p">,</span><span class="n">proc_dim</span><span class="p">,</span><span class="n">trend</span><span class="p">)</span>
                <span class="n">_trend_removal</span><span class="p">(</span><span class="n">data_proc_ref</span><span class="p">,</span><span class="n">proc_dim_ref</span><span class="p">,</span><span class="n">trend</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hanning</span><span class="p">):</span>
           <span class="n">data_proc</span> <span class="o">*=</span> <span class="n">hanning_window</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data_proc</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
           <span class="n">data_proc_ref</span> <span class="o">*=</span> <span class="n">hanning_window_ref</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data_proc_ref</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Calculating FFT</span>
        <span class="n">dfft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">data_proc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">proc_dim</span><span class="p">)</span>
        <span class="n">dfft_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">data_proc_ref</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">proc_dim_ref</span><span class="p">)</span>
        <span class="n">dps</span><span class="p">,</span> <span class="n">axis_source</span><span class="p">,</span> <span class="n">axis_number</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">multiply_along_axes</span><span class="p">(</span><span class="n">dfft</span><span class="p">,</span> 
                                                                       <span class="n">dfft_ref</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> 
                                                                       <span class="p">[</span><span class="n">proc_dim</span><span class="p">,</span> <span class="n">proc_dim_ref</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
            <span class="n">dfft_aps</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfft</span> <span class="o">*</span> <span class="n">dfft</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
            <span class="n">dfft_aps_ref</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfft_ref</span> <span class="o">*</span> <span class="n">dfft_ref</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># Rearranging the negative frequencies</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_in2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">dps1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dps</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dps</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">dps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)]</span>
            <span class="n">dps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2</span><span class="p">)]</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="n">dps1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
                <span class="n">dfft_aps1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dfft_aps</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dfft_aps</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>   <span class="c1">#THIS USED TO BE dfft_aps1 WHICH IS UNDEFINED</span>
                <span class="n">dfft_aps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1_apsd</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dfft_aps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1_apsd</span><span class="p">)]</span>
                <span class="n">dfft_aps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2_apsd</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dfft_aps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2_apsd</span><span class="p">)]</span>
                <span class="n">dfft_aps</span> <span class="o">=</span> <span class="n">dfft_aps1</span>
                <span class="n">dfft_aps1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dfft_aps_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dfft_aps_ref</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">dfft_aps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1_apsd_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dfft_aps_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1_apsd_ref</span><span class="p">)]</span>
                <span class="n">dfft_aps1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2_apsd_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dfft_aps_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2_apsd_ref</span><span class="p">)]</span>
                <span class="n">dfft_aps_ref</span> <span class="o">=</span> <span class="n">dfft_aps1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
                <span class="n">dfft_aps</span> <span class="o">=</span> <span class="n">dfft_aps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1_apsd</span><span class="p">)]</span>
                <span class="n">dfft_aps_ref</span> <span class="o">=</span> <span class="n">dfft_aps_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1_apsd_ref</span><span class="p">)]</span>
        <span class="c1"># Cutting the range</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">ind_slice</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="n">dps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
                <span class="n">dfft_aps</span> <span class="o">=</span> <span class="n">dfft_aps</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice_apsd</span><span class="p">)]</span>
                <span class="n">dfft_aps_ref</span> <span class="o">=</span> <span class="n">dfft_aps_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice_apsd_ref</span><span class="p">)]</span>
        <span class="c1"># Binning the spectrum and summing up the time intervals</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_bin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">out_data_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">out_data_interval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin</span><span class="p">),</span> <span class="n">dps</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
                <span class="n">apsd_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">apsd_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">apsd_interval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin_apsd</span><span class="p">),</span> <span class="n">dfft_aps</span><span class="p">)</span>
                <span class="n">apsd_ref_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">apsd_ref_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">apsd_ref_interval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin_apsd_ref</span><span class="p">),</span> <span class="n">dfft_aps_ref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_data_interval</span> <span class="o">=</span> <span class="n">dps</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
                <span class="n">apsd_interval</span>  <span class="o">=</span> <span class="n">dfft_aps</span>
                <span class="n">apsd_ref_interval</span> <span class="o">=</span> <span class="n">dfft_aps_ref</span>
        <span class="c1"># Dividing by the number of points in each bin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">out_data_interval</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_nonzero</span><span class="p">)]</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="p">[</span><span class="n">index_nonzero</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
                <span class="n">apsd_interval</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_nonzero_apsd</span><span class="p">)]</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="p">[</span><span class="n">index_nonzero</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs_apsd</span><span class="p">)</span>
                <span class="n">apsd_ref_interval</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_nonzero_apsd_ref</span><span class="p">)]</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="p">[</span><span class="n">index_nonzero</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs_apsd_ref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_data_interval</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
            <span class="n">apsd_interval</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs_apsd</span><span class="p">)</span>
            <span class="n">apsd_ref_interval</span> <span class="o">/=</span> <span class="n">out_data_num</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bs_apsd_ref</span><span class="p">)</span>
        <span class="n">out_data_interval</span> <span class="o">/=</span> <span class="n">interval_sample_n</span>
        <span class="n">out_data</span> <span class="o">+=</span> <span class="n">out_data_interval</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
            <span class="n">apsd_interval</span> <span class="o">/=</span> <span class="n">interval_sample_n</span>
            <span class="n">apsd_ref_interval</span> <span class="o">/=</span> <span class="n">interval_sample_n</span>
            <span class="n">apsd</span> <span class="o">+=</span> <span class="n">apsd_interval</span>
            <span class="n">apsd_ref</span> <span class="o">+=</span> <span class="n">apsd_ref_interval</span>
                        
    <span class="n">out_data</span> <span class="o">/=</span> <span class="n">n_proc_int</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aps_calc</span><span class="p">):</span>
       <span class="n">apsd_norm</span><span class="p">,</span> <span class="n">axis_source</span><span class="p">,</span> <span class="n">axis_number</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">multiply_along_axes</span><span class="p">(</span><span class="n">apsd</span><span class="p">,</span> 
                                                                            <span class="n">apsd_ref</span><span class="p">,</span> 
                                                                            <span class="p">[</span><span class="n">proc_dim</span><span class="p">,</span> <span class="n">proc_dim_ref</span><span class="p">])</span>
       <span class="n">apsd_norm</span> <span class="o">/=</span> <span class="n">n_proc_int</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">norm</span><span class="p">):</span> 
       <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
           <span class="n">out_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_nonzero</span><span class="p">)]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">apsd_norm</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_nonzero</span><span class="p">)])</span>
       <span class="k">else</span><span class="p">:</span>
           <span class="n">out_data</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">apsd_norm</span><span class="p">)</span>
    <span class="c1"># If there are frequency bins without data setting them to np.NaN</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">out_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_zero</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
    <span class="c1"># Putting significance into error</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">error_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">out_data_num</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ind_nonzero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">error_arr</span><span class="p">[</span><span class="n">index_nonzero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out_data_num</span><span class="p">[</span><span class="n">index_nonzero</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_proc_int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">error_arr</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out_data_num</span> <span class="o">*</span> <span class="n">n_proc_int</span><span class="p">)</span>
    <span class="n">es</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
    <span class="n">es</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_shape</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">]</span>
    <span class="n">error</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">error_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">es</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">norm</span> <span class="ow">and</span> <span class="n">error_calc</span><span class="p">):</span>
        <span class="n">error</span> <span class="o">*=</span> <span class="n">apsd_norm</span>
      
    <span class="c1">#Assembling the coordinates</span>
    <span class="n">coord_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">coordinate</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If this coordinate has no common dimension with the processing</span>
            <span class="c1"># then it will stay</span>
            <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="c1"># Has to update the dimension list</span>
            <span class="k">for</span> <span class="n">idim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis_number</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">axis_source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
                          <span class="ow">and</span> <span class="p">(</span><span class="n">axis_number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="n">idim</span><span class="p">])):</span>
                        <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal error, cannot find dimension mapping (1).&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">coordinate</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ref_coord_obj</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If this coordinate has no common dimension with the processing</span>
            <span class="c1"># then it will stay</span>
            <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="c1"># Has to update the dimension list</span>
            <span class="k">for</span> <span class="n">idim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis_number</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">axis_source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> 
                          <span class="ow">and</span> <span class="p">(</span><span class="n">axis_number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="n">idim</span><span class="p">])):</span>
                        <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal error, cannot find dimension mapping (2).&quot;</span><span class="p">)</span>
            <span class="c1"># Checking whether there is already an axis with this name</span>
            <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">coord_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; (Ref)&#39;</span>
    
    <span class="c1"># Adding the frequency/wavenumber coordinate            </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wavenumber</span><span class="p">):</span>
        <span class="n">out_name</span> <span class="o">=</span> <span class="s1">&#39;Wavenumber&#39;</span>
        <span class="n">out_unit</span> <span class="o">=</span> <span class="s1">&#39;1/&#39;</span><span class="o">+</span><span class="n">coord_obj</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">res</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1">#fcent *= 2* math.pi                                                        #UNUSED VARIABLE</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_name</span> <span class="o">=</span> <span class="s1">&#39;Frequency&#39;</span>
        <span class="n">out_unit</span> <span class="o">=</span> <span class="s1">&#39;Hz&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">log_scale</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Coordinate</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">out_name</span><span class="p">,</span>
                                       <span class="n">unit</span> <span class="o">=</span> <span class="n">out_unit</span><span class="p">,</span>
                                       <span class="n">mode</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">CoordinateMode</span><span class="p">(</span><span class="n">equidistant</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                       <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">f_cent</span><span class="o">.</span><span class="n">size</span><span class="p">],</span>
                                       <span class="n">values</span> <span class="o">=</span> <span class="n">f_cent</span><span class="p">,</span>
                                       <span class="n">dimension_list</span><span class="o">=</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Coordinate</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">out_name</span><span class="p">,</span>
                                       <span class="n">unit</span> <span class="o">=</span> <span class="n">out_unit</span><span class="p">,</span>
                                       <span class="n">mode</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">CoordinateMode</span><span class="p">(</span><span class="n">equidistant</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                       <span class="n">shape</span> <span class="o">=</span> <span class="p">[],</span>
                                       <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcent_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">zero_ind</span><span class="p">)</span> <span class="o">*</span> <span class="n">res</span><span class="p">,</span>
                                       <span class="n">step</span> <span class="o">=</span> <span class="n">res</span><span class="p">,</span>
                                       <span class="n">dimension_list</span><span class="o">=</span><span class="p">[</span><span class="n">proc_dim</span><span class="p">])</span>
    <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">norm</span><span class="p">):</span>
        <span class="n">unit_name</span> <span class="o">=</span> <span class="s1">&#39;Coherency&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unit_name</span> <span class="o">=</span> <span class="s1">&#39;Spectral density&#39;</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">exp_id</span> <span class="o">==</span> <span class="n">_ref</span><span class="o">.</span><span class="n">exp_id</span><span class="p">):</span>
        <span class="n">exp_id_out</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">exp_id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exp_id_out</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># We create the new data object with this trick as data_object.py cannot be imported</span>
    <span class="n">d_out</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)(</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">,</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">,</span>
                    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coord_list</span><span class="p">,</span>
                    <span class="n">exp_id</span> <span class="o">=</span> <span class="n">exp_id_out</span><span class="p">,</span>
                    <span class="n">data_unit</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">unit_name</span><span class="p">)</span>
                    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">d_out</span>

<span class="k">def</span> <span class="nf">_ccf</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        N dimensional Cross Correlation Function or covariance calculation for the data object d taking d_ref </span>
<span class="sd">        as reference. If ref is not set d is used as reference, that is all CCFs are calculated </span>
<span class="sd">        within d. Calculates all CCF between all signals in ref and d, but not inside d and ref.</span>
<span class="sd">        Correlation is calculated along the coordinate(s) listed in coordinate which should be</span>
<span class="sd">        identical for the to input data objects.</span>
<span class="sd">        Returns a data object with dimension number d.dim+ref.dim-len(coordinate). </span>
<span class="sd">        The coordinates are replaced by coordinate+&#39; lag&#39;.</span>
<span class="sd">        The CCF is calculated in multiple intervals (described by intervals)</span>
<span class="sd">        and the mean and variance will be returned.</span>
<span class="sd">    </span>
<span class="sd">        INPUT:</span>
<span class="sd">            d: A flap.DataObject.</span>
<span class="sd">            ref: Another flap.DataObject</span>
<span class="sd">            coordinate: The name of the coordinate (string) along which to calculate CCF or a list of names.</span>
<span class="sd">                        Each coordinate should change only along one data dimension and should be equidistant.</span>
<span class="sd">                        This and all other cordinates changing along the data dimension of</span>
<span class="sd">                        these coordinates will be removed. New coordinates with name+&#39; lag&#39; will be added. </span>
<span class="sd">            intervals: Information of processing intervals.</span>
<span class="sd">                       If dictionary with a single key: {selection coordinate: description})</span>
<span class="sd">                           Key is a coordinate name which can be different from the calculation</span>
<span class="sd">                           coordinate.</span>
<span class="sd">                           Description can be flap.Intervals, flap.DataObject or</span>
<span class="sd">                           a list of two numbers. If it is a data object with data name identical to</span>
<span class="sd">                           the coordinate the error ranges of the data object will be used for</span>
<span class="sd">                           interval. If the data name is not the same as coordinate a coordinate with the</span>
<span class="sd">                           same name will be searched for in the data object and the value_ranges</span>
<span class="sd">                           will be used fromm it to set the intervals.</span>
<span class="sd">                       If not a dictionary and not None it is interpreted as the interval</span>
<span class="sd">                           description, the selection coordinate is taken the same as</span>
<span class="sd">                           (the first) coordinate.</span>
<span class="sd">                       If None, the whole data interval will be used as a single interval.</span>
<span class="sd">            options: Dictionary. (Keys can be abbreviated)</span>
<span class="sd">                &#39;Resolution&#39;: Output resolution for each coordinate. (list of values or single value)</span>
<span class="sd">                &#39;Range&#39;: Output ranges for each coordinate. (List or list of lists)</span>
<span class="sd">                &#39;Interval_n&#39;: Minimum number of intervals to use for the processing. These are identical</span>
<span class="sd">                              length intervals inserted into the input interval list. Default is 8.</span>
<span class="sd">                &#39;Error calculation&#39; : True/False. Calculate or not error. Omitting error calculation</span>
<span class="sd">                                      increases speed. If Interval_n is 1 no error calculation is done.</span>
<span class="sd">                &#39;Trend removal&#39;: Trend removal description (see also _trend_removal()). A list, string or None.</span>
<span class="sd">                             None: Don&#39;t remove trend.</span>
<span class="sd">                             Strings:</span>
<span class="sd">                               &#39;mean&#39;: subtract mean</span>
<span class="sd">                             Lists:</span>
<span class="sd">                               [&#39;Poly&#39;, n]: Fit an n order polynomial to the data and subtract.</span>
<span class="sd">                            Trend removal will be applied to each interval separately.</span>
<span class="sd">                            At present trend removal can be applied to 1D CCF only.</span>
<span class="sd">                &#39;Normalize&#39;: Normalize with autocorrelations, that is calculate correlation instead of </span>
<span class="sd">                             covariance.</span>
<span class="sd">                &#39;Verbose&#39;: Print progress messages</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot do correlation calculation without data.&quot;</span><span class="p">)</span>

    <span class="n">default_options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Resolution&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s1">&#39;Range&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s1">&#39;Interval_n&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                       <span class="s1">&#39;Trend removal&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Poly&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                       <span class="s1">&#39;Error calculation&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="s1">&#39;Normalize&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="s1">&#39;Verbose&#39;</span><span class="p">:</span><span class="kc">True</span>
                       <span class="p">}</span>
    <span class="n">_options</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">merge_options</span><span class="p">(</span><span class="n">default_options</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">data_source</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;Correlation&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">c_names</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">coordinate_names</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
            <span class="n">_coordinate</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No coordinate is given for correlation calculation and no Time coordinate found.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">_coordinate</span> <span class="o">=</span> <span class="n">coordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_coordinate</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinate</span><span class="p">]</span>

    <span class="n">trend</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Trend removal&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Trend removal for multi-dimensional correlation is not implemented.&quot;</span><span class="p">)</span>
    <span class="n">interval_n</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Interval_n&#39;</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Normalize&#39;</span><span class="p">]</span>
    <span class="n">error_calc</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Error calculation&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Interval selection for multi-dimensional correlation is not implemented.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">error_calc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">interval_n</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="c1"># Getting coordinate objects and checking properties    </span>
    <span class="n">coord_obj</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># This will contain the dimension list in d.data and the output of the correlations</span>
    <span class="n">correlation_dimensions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c_name</span> <span class="ow">in</span> <span class="n">_coordinate</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get_coordinate_object</span><span class="p">(</span><span class="n">c_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>      
        <span class="n">coord_obj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation calculation is possible only along coordinates changing in one dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">equidistant</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation calculation is possible only along equidistant coordinates.&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">correlation_dimensions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate multi dimensional correlation with common dimensions.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">correlation_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">_ref</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">coord_obj_ref</span> <span class="o">=</span> <span class="n">coord_obj</span>
        <span class="n">correlation_dimensions_ref</span> <span class="o">=</span> <span class="n">correlation_dimensions</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">intervals</span><span class="p">,</span> <span class="n">index_intervals</span> <span class="o">=</span> <span class="n">_spectral_calc_interval_selection</span><span class="p">(</span><span class="n">d</span><span class="p">,</span>
                                                                           <span class="kc">None</span><span class="p">,</span> 
                                                                           <span class="n">_coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                           <span class="n">intervals</span><span class="p">,</span>
                                                                           <span class="n">interval_n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_ref</span> <span class="o">=</span> <span class="n">ref</span>
        <span class="n">coord_obj_ref</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">correlation_dimensions_ref</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">_ref</span><span class="o">.</span><span class="n">get_coordinate_object</span><span class="p">(</span><span class="n">c_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>      
            <span class="n">coord_obj_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation calculation is possible only along coordinates changing in one dimension.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">equidistant</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation calculation is possible only along equidistant coordinates.&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">correlation_dimensions_ref</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate multi dimensional correlation with common dimensions.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">correlation_dimensions_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_obj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-4</span><span class="p">):</span>
                   <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible coordinate step sizes.&quot;</span> <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">coord_obj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                   <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible coordinate start values.&quot;</span> <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">correlation_dimensions_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
                           <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">correlation_dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]]):</span>
                   <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible data dimensions.&quot;</span> <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">intervals</span><span class="p">,</span> <span class="n">index_intervals</span> <span class="o">=</span> <span class="n">_spectral_calc_interval_selection</span><span class="p">(</span><span class="n">d</span><span class="p">,</span>
                                                                           <span class="n">_ref</span><span class="p">,</span> 
                                                                           <span class="n">_coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                           <span class="n">intervals</span><span class="p">,</span>
                                                                           <span class="n">interval_n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
                        
    <span class="n">interval_n</span><span class="p">,</span> <span class="n">start_ind</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_number</span><span class="p">()</span>
    <span class="n">int_low</span><span class="p">,</span> <span class="n">int_high</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_limits</span><span class="p">()</span>
    <span class="n">index_int_low</span><span class="p">,</span> <span class="n">index_int_high</span> <span class="o">=</span> <span class="n">index_intervals</span><span class="o">.</span><span class="n">interval_limits</span><span class="p">()</span>
    <span class="c1"># Number of processing intervals</span>
    <span class="n">n_proc_int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_low</span><span class="p">)</span>
    <span class="c1"># Numper of points in the selection coordinate</span>
    <span class="n">n_sample_sel</span> <span class="o">=</span> <span class="n">index_int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Creating indices to take out data for each processing interval and place it into the processing arrays</span>
    <span class="n">interval_slice_1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
    <span class="n">interval_out_slice</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interval_slice_1</span><span class="p">)</span>
    <span class="n">interval_out_slice</span><span class="p">[</span><span class="n">correlation_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_sample_sel</span><span class="p">)</span>
    <span class="n">interval_slice</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_proc_int</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
        <span class="n">interval_slice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interval_slice_1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
        <span class="n">interval_slice</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">correlation_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_int_low</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">index_int_high</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">interval_slice_ref_1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="n">interval_out_slice_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interval_slice_ref_1</span><span class="p">)</span>
        <span class="n">interval_out_slice_ref</span><span class="p">[</span><span class="n">correlation_dimensions_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_sample_sel</span><span class="p">)</span>
        <span class="n">interval_slice_ref</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_proc_int</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
            <span class="n">interval_slice_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interval_slice_ref_1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
            <span class="n">interval_slice_ref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">correlation_dimensions_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_int_low</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">index_int_high</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Number of correlation points in the correlation dimensions after FFT before binning </span>
    <span class="n">corr_point_n_nat</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">correlation_dimensions</span><span class="p">]</span>   
    <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_sample_sel</span>
    
    <span class="c1"># Setting resolution</span>
    <span class="n">corr_res</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Resolution&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">corr_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">corr_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord_obj</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">corr_res</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">corr_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_res</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span>
    <span class="n">corr_range</span> <span class="o">=</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Range&#39;</span><span class="p">]</span>
    <span class="c1">#Setting default correlation range to 10-th of coordinate range </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">corr_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">corr_range</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_obj</span><span class="p">):</span>
            <span class="n">corr_range</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span><span class="mi">10</span> <span class="p">,</span> 
                               <span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span><span class="mi">10</span>
                               <span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">corr_range</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation range must be a list.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">corr_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">corr_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_range</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">_coordinate</span><span class="p">)</span>
    <span class="c1"># Sanity check for lag range</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_obj</span><span class="p">):</span>
        <span class="n">dr</span><span class="p">,</span> <span class="n">dr1</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">data_range</span><span class="p">(</span><span class="n">data_shape</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">int_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">int_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation lag calculation range is too large for coordinate &#39;</span><span class="si">{:s}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Correlation lag calculation range is too small for coordinate &#39;</span><span class="si">{:s}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid correlation lag range for coordinate &#39;</span><span class="si">{:s}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="c1"># Correlation final resolutions in sample numbers</span>
    <span class="n">corr_res_sample</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Correlation range in final resolution</span>
    <span class="n">range_sampout</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Number of correlation points at final resolution</span>
    <span class="n">n_corr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The shift range in original sample numbers</span>
    <span class="n">shift_range</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Number of 0 samples to add in each correlation dimensions to prevent correlation from wrapping around</span>
    <span class="n">pad_length</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_obj</span><span class="p">):</span>
        <span class="c1"># Resolutions in sample number. Ensuring that it is odd sample</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">corr_res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">coord</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">corr_res_sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="c1"># Correlation point ranges in output sample number</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid correlation range description. Must be 2-element list.&quot;</span><span class="p">)</span>
        <span class="n">r_samp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">corr_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">corr_res_sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
        <span class="n">r_samp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r_samp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">range_sampout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_samp</span><span class="p">)</span>
        <span class="n">n_corr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_samp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">shift_range</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">corr_res_sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">corr_res_sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                            <span class="n">r_samp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">corr_res_sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">corr_res_sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>
        <span class="n">pad_length</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">shift_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])]))</span>
        <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pad_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
    <span class="c1"># Check if we have lag 0 data in  all dimensions</span>
    <span class="n">lag0_present</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">range_sampout</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">range_sampout</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">lag0_present</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="c1"># This flag indicates whether we need to calculate ACFs separately</span>
    <span class="n">calc_acf</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">lag0_present</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Normalize&#39;</span><span class="p">]</span>
                
    <span class="c1"># Determining the output shape. First the dimensions of d without the common dimensions, </span>
    <span class="c1"># then the common dimensions, then the reference with the calculation dimensions removed</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">correlation_dimensions_out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out_shape_acf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out_shape_acf_ref</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">correlation_dimensions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="n">out_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">out_shape_acf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
        <span class="n">out_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_corr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">out_shape_acf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_corr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">out_shape_acf_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_corr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">correlation_dimensions_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">correlation_dimensions_ref</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="n">out_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">out_shape_acf_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Array shapes for doing FFT</span>
    <span class="n">proc_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">proc_shape_ref</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
    <span class="n">pad_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">):</span>
        <span class="n">pad_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">pad_length</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">proc_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">pad_slice_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">correlation_dimensions_ref</span><span class="p">):</span>
            <span class="n">pad_slice_ref</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">pad_length</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
            <span class="n">proc_shape_ref</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># Index arrays to rearrange after FFT and multiplying</span>
    <span class="n">ind_in1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
    <span class="n">ind_in2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
    <span class="n">ind_out1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
    <span class="n">ind_out2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">calc_acf</span><span class="p">):</span>
        <span class="c1"># We need to calculate APSDs separately</span>
        <span class="n">ind_in1_acf</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape_acf</span><span class="p">]</span>
        <span class="n">ind_in2_acf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_acf</span><span class="p">)</span>
        <span class="n">ind_out1_acf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_acf</span><span class="p">)</span>
        <span class="n">ind_out2_acf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_acf</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_in1_acf_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape_acf_ref</span><span class="p">]</span>
            <span class="n">ind_in2_acf_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_acf_ref</span><span class="p">)</span>
            <span class="n">ind_out1_acf_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_acf_ref</span><span class="p">)</span>
            <span class="n">ind_out2_acf_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_in1_acf_ref</span><span class="p">)</span>
            
    <span class="c1"># zero_ind is the index where the 0 time lag will be after rearranging the CCF to final form</span>
    <span class="n">zero_ind</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)</span>
    <span class="c1"># A slicing list which will cut out the needed part of the CCF</span>
    <span class="c1"># The CCF will have first the remaining dimensions of d, then the correlation dimensions, </span>
    <span class="c1"># then the remaining dimensions of ref</span>
    <span class="n">ind_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
    <span class="n">ind_bin</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_slice</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">calc_acf</span><span class="p">):</span>
        <span class="n">ind_slice_acf</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">out_shape_acf</span><span class="p">]</span>
        <span class="n">ind_bin_acf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_slice_acf</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">ind_slice_acf_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">out_shape_acf_ref</span><span class="p">]</span>
            <span class="n">ind_bin_acf_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_slice_acf_ref</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">correlation_dimensions_out</span><span class="p">):</span>
        <span class="n">nfft</span> <span class="o">=</span> <span class="n">corr_point_n_nat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ind_in1</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nfft</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">ind_out1</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nfft</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">nfft</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">nfft</span><span class="p">)</span>
        <span class="n">zero_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfft</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">nfft</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ind_in2</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nfft</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span><span class="n">nfft</span><span class="p">)</span>
        <span class="n">ind_out2</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nfft</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">nfft</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">ind_slice</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">shift_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">zero_ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shift_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">zero_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ind_bin</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ind_slice</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">ind_slice</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">//</span> <span class="n">corr_res_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">calc_acf</span><span class="p">):</span>
            <span class="n">ind_in1_acf</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_in1</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
            <span class="n">ind_out1_acf</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_out1</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
            <span class="n">ind_in2_acf</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_in2</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
            <span class="n">ind_out2_acf</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_out2</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
            <span class="n">ind_slice_acf</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_slice</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
            <span class="n">ind_bin_acf</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>  <span class="o">=</span> <span class="n">ind_bin</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">ind_in1_acf_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_in1</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
                <span class="n">ind_out1_acf_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_out1</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
                <span class="n">ind_in2_acf_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_in2</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
                <span class="n">ind_out2_acf_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_out2</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
                <span class="n">ind_slice_acf_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_slice</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
                <span class="n">ind_bin_acf_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">ind_bin</span><span class="p">[</span><span class="n">cd</span><span class="p">]</span>
                
    <span class="c1"># The processing array for each interval, data will be read here                </span>
    <span class="n">proc_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">proc_shape</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">proc_array_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">proc_shape_ref</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># The output array    </span>
    <span class="k">if</span> <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;c&#39;</span><span class="p">)):</span>
        <span class="n">out_dtype</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_dtype</span><span class="o">=</span> <span class="nb">complex</span>
    <span class="n">out_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error_calc</span><span class="p">):</span>
        <span class="n">out_corr_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>  
    <span class="n">all_points</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
        <span class="n">all_points</span> <span class="o">*=</span> <span class="n">n_corr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i_int</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_options</span><span class="p">[</span><span class="s1">&#39;Verbose&#39;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Interval </span><span class="si">{:d}</span><span class="s2">/</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_int</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_proc_int</span><span class="p">))</span>
        <span class="c1"># Taking data for this processing interval</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">trend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">proc_array_trend</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_slice</span><span class="p">[</span><span class="n">i_int</span><span class="p">])])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_trend_removal</span><span class="p">(</span><span class="n">proc_array_trend</span><span class="p">,</span><span class="n">correlation_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">trend</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
            <span class="n">proc_array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_out_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">proc_array_trend</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc_array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_out_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_slice</span><span class="p">[</span><span class="n">i_int</span><span class="p">])]</span>
        <span class="n">proc_array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pad_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">proc_array</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">correlation_dimensions</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">trend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">proc_array_trend_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_slice_ref</span><span class="p">[</span><span class="n">i_int</span><span class="p">])])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_trend_removal</span><span class="p">(</span><span class="n">proc_array_trend_ref</span><span class="p">,</span><span class="n">correlation_dimensions_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">trend</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="n">proc_array_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_out_slice_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="n">proc_array_trend_ref</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proc_array_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_out_slice_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">interval_slice_ref</span><span class="p">[</span><span class="n">i_int</span><span class="p">])]</span>
            <span class="n">proc_array_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pad_slice_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">fft_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">proc_array_ref</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">correlation_dimensions_ref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fft_ref</span> <span class="o">=</span> <span class="n">fft</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">axis_source</span><span class="p">,</span> <span class="n">axis_number</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">multiply_along_axes</span><span class="p">(</span><span class="n">fft</span><span class="p">,</span> 
                                                                 <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">fft_ref</span><span class="p">),</span>
                                                                 <span class="p">[</span><span class="n">correlation_dimensions</span><span class="p">,</span><span class="n">correlation_dimensions_ref</span><span class="p">],</span>
                                                                 <span class="n">keep_a1_dims</span> <span class="o">=</span> <span class="kc">False</span>
                                                                 <span class="p">)</span>
        <span class="n">corr_dim_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)</span>
        <span class="n">cps_corr_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="n">corr_dim_start</span> 
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">cps_corr_dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out_dtype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>        
        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">corr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1</span><span class="p">)]</span>
        <span class="n">corr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2</span><span class="p">)]</span>
        <span class="n">corr_sliced</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice</span><span class="p">)]</span>
        <span class="n">corr_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">corr_binned</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin</span><span class="p">),</span><span class="n">corr_sliced</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">norm</span><span class="p">):</span>
            <span class="n">zero_ind_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
                <span class="n">zero_ind_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">range_sampout</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">calc_acf</span><span class="p">):</span>
                <span class="c1"># We already have the autocorrelations</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
                    <span class="c1"># There is a single correlation function</span>
                    <span class="n">corr_binned</span> <span class="o">/=</span> <span class="n">corr_binned</span><span class="p">[</span><span class="n">zero_ind_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corr_dimension_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)</span>
                    <span class="n">autocorr_index_shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[:</span><span class="n">corr_dimension_start</span><span class="p">])</span>
                    <span class="n">ind_autocorr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">autocorr_index_shape</span><span class="p">)):</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                        <span class="n">temp_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">autocorr_index_shape</span><span class="p">)</span>
                        <span class="n">temp_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocorr_index_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">temp_shape</span><span class="p">))</span>
                        <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">autocorr_index_shape</span><span class="p">)</span>
                        <span class="n">tile_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">ind_autocorr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="n">tile_shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
                        <span class="n">ind_autocorr</span><span class="p">[</span><span class="n">corr_dimension_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">autocorr_index_shape</span><span class="p">),</span><span class="n">zero_ind_out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ind_autocorr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">autocorr_index_shape</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">):]</span> \
                           <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ind_autocorr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">autocorr_index_shape</span><span class="p">)])</span>     
                    <span class="n">autocorr_mx</span> <span class="o">=</span> <span class="n">corr_binned</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_autocorr</span><span class="p">)]</span>
                    <span class="n">extend_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">autocorr_mx</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="n">corr_binned</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">autocorr_mx</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">autocorr_mx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">extend_shape</span><span class="p">)))</span>
                    <span class="n">corr_binned</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">autocorr_mx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extend_shape</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">autocorr_mx</span><span class="o">.</span><span class="n">shape</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We do not have the autocorrelations, calculating</span>
                <span class="n">res_acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fft</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">fft</span><span class="p">),</span><span class="n">axes</span><span class="o">=</span><span class="n">correlation_dimensions</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">out_dtype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">res_acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">res_acf</span><span class="p">)</span>
                <span class="c1"># we need to move the correlation axes to the end to be consistent with the CCF</span>
                <span class="n">res_acf</span><span class="p">,</span> <span class="n">ax_map</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">move_axes_to_end</span><span class="p">(</span><span class="n">res_acf</span><span class="p">,</span><span class="n">correlation_dimensions</span><span class="p">)</span>
                <span class="n">corr_acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">res_acf</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">corr_acf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1_acf</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_acf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1_acf</span><span class="p">)]</span>
                <span class="n">corr_acf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2_acf</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_acf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2_acf</span><span class="p">)]</span>
                <span class="n">corr_sliced_acf</span> <span class="o">=</span> <span class="n">corr_acf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice_acf</span><span class="p">)]</span>
                <span class="n">corr_binned_acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape_acf</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">res_acf</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">corr_binned_acf</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin_acf</span><span class="p">),</span><span class="n">corr_sliced_acf</span><span class="p">)</span>
                <span class="c1"># We need to take the zero lag elements from each correlation dimension</span>
                <span class="n">corr_dimension_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_shape_acf</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
                    <span class="c1"># Always the cor_dimension_start axis is taken as it is removed by take</span>
                    <span class="n">corr_binned_acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">corr_binned_acf</span><span class="p">,</span><span class="n">zero_ind_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">corr_dimension_start</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">res_acf_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fft_ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">fft_ref</span><span class="p">),</span><span class="n">axes</span><span class="o">=</span><span class="n">correlation_dimensions_ref</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">out_dtype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">):</span>
                        <span class="n">res_acf_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">res_acf_ref</span><span class="p">)</span>
                    <span class="c1"># we need to move the correlation axes to the start to be consistent with the CCF</span>
                    <span class="n">res_acf_ref</span><span class="p">,</span><span class="n">ax_map_ref</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">move_axes_to_start</span><span class="p">(</span><span class="n">res_acf_ref</span><span class="p">,</span><span class="n">correlation_dimensions_ref</span><span class="p">)</span>
                    <span class="n">corr_acf_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">res_acf_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">res_acf</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">corr_acf_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out1_acf_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_acf_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in1_acf_ref</span><span class="p">)]</span>
                    <span class="n">corr_acf_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_out2_acf_ref</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_acf_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_in2_acf_ref</span><span class="p">)]</span>
                    <span class="n">corr_sliced_acf_ref</span> <span class="o">=</span> <span class="n">corr_acf_ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_slice_acf_ref</span><span class="p">)]</span>
                    <span class="n">corr_binned_acf_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape_acf_ref</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">res_acf_ref</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">corr_binned_acf_ref</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind_bin_acf_ref</span><span class="p">),</span><span class="n">corr_sliced_acf_ref</span><span class="p">)</span>
                    <span class="c1"># We need to take the zero lag elements from each correlation dimension</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)):</span>
                        <span class="c1"># Always the cor_dimension_start axis is taken as it is removed by take</span>
                        <span class="n">corr_binned_acf_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">corr_binned_acf_ref</span><span class="p">,</span><span class="n">zero_ind_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corr_binned_acf_ref</span> <span class="o">=</span> <span class="n">corr_binned_acf</span>
                <span class="n">extend_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_binned_acf</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">corr_binned</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">corr_binned_acf</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">corr_binned_acf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">extend_shape</span><span class="p">)))</span>
                <span class="n">extend_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_binned_acf_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">corr_binned</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">corr_binned_acf_ref</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="n">extend_shape</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">corr_binned_acf_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corr_binned</span> <span class="o">/=</span> <span class="n">all_points</span>
        <span class="n">out_corr</span> <span class="o">+=</span> <span class="n">corr_binned</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error_calc</span><span class="p">):</span>   
            <span class="n">out_corr_square</span> <span class="o">+=</span> <span class="n">corr_binned</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">out_corr</span> <span class="o">/=</span> <span class="n">n_proc_int</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error_calc</span><span class="p">):</span>
        <span class="n">out_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">out_corr_square</span> <span class="o">/</span> <span class="n">n_proc_int</span> <span class="o">-</span> <span class="n">out_corr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                                  <span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_proc_int</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_error</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1">#Assembling the coordinates</span>
    <span class="c1"># Removing all coordinates which have common dimensions with the correlation coordinates</span>
    <span class="n">coord_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">correlation_dimensions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i_dim</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis_source</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">axis_source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axis_number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span><span class="p">)):</span>
                       <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_ref</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">correlation_dimensions_ref</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i_dim</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis_source</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">axis_source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axis_number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span><span class="p">)):</span>
                       <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_list</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># Checking whether there is already an axis with this name</span>
            <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">coord_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">coord_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; (Ref)&#39;</span>
    
    <span class="c1"># Adding the correlation coordinates</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_obj</span><span class="p">):</span>           
        <span class="n">c_new</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Coordinate</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; lag&#39;</span><span class="p">,</span>
                                           <span class="n">unit</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                           <span class="n">mode</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">CoordinateMode</span><span class="p">(</span><span class="n">equidistant</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                           <span class="n">shape</span> <span class="o">=</span> <span class="p">[],</span>
                                           <span class="n">start</span> <span class="o">=</span> <span class="n">range_sampout</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">corr_res_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="n">step</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_res_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                           <span class="n">dimension_list</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">correlation_dimensions</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_new</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">norm</span><span class="p">):</span>
        <span class="n">unit_name</span> <span class="o">=</span> <span class="s1">&#39;Correlation&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unit_name</span> <span class="o">=</span> <span class="s1">&#39;Covariance&#39;</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">exp_id</span> <span class="o">==</span> <span class="n">_ref</span><span class="o">.</span><span class="n">exp_id</span><span class="p">):</span>
        <span class="n">exp_id_out</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">exp_id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exp_id_out</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># We create the new data object with this trick as data_object.py cannot be imported</span>
    <span class="n">d_out</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)(</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">out_corr</span><span class="p">,</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">out_error</span><span class="p">,</span>
                    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coord_list</span><span class="p">,</span>
                    <span class="n">exp_id</span> <span class="o">=</span> <span class="n">exp_id_out</span><span class="p">,</span>
                    <span class="n">data_unit</span> <span class="o">=</span> <span class="n">flap</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">unit_name</span><span class="p">)</span>
                    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">d_out</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">FLAP</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../styleguide.html">FLAP Styleguide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sourcecode.html">FLAP source code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage of FLAP (tips/tricks/faq)</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, S. Zoletnik et al..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>